\documentclass[oneside,bibliography=totocnumbered,BCOR=5mm]{scrbook}

\usepackage[ngerman]{babel}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
% \setmainfont{Times}
\setmonofont{FuraCode Nerd Font Mono} % from fc-list

\usepackage[
backend=biber,
style=numeric,
citestyle=authoryear,
autocite=footnote
]{biblatex}
\addbibresource{bibliography.bib}
\addbibresource{extra.bib}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage[newfloat]{minted}
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}

\newenvironment{code}{\captionsetup{type=listing, skip=0pt}}{}
\SetupFloatingEnvironment{listing}{name=Code}

\newminted{shell}{
  linenos,
  numbersep=6pt,
  frame=lines,
  framesep=2mm,
  fontsize=\footnotesize
}
\newminted{javascript}{
  linenos,
  numbersep=6pt,
  frame=lines,
  framesep=2mm,
  fontsize=\footnotesize
}
\newmintinline[codeinline]{shell}{
  fontsize=\small
}

%%%%%% other packages %%%%%%

\usepackage{marvosym}
\usepackage{csquotes}
\usepackage{hyperref}

% \usepackage[hyphens]{url}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

% \usepackage{abstract} % Allows abstract customization
% \renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
% \renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

% \usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
% \titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
% \titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
% \fancyhead[C]{Ethics in Progress (EiP) $\bullet$ 2019 } % Custom header text
% \fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\begin{document}

% Titelseite
% \pagestyle{empty}       % keine Seitennummer
\begin{titlepage}
\begin{center}
\includegraphics{htw-logo.jpg}
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\textit{\large Entwicklung und Evaluation von Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen-Interfaces}
\linebreak[4]
\linebreak[4]
\linebreak[4]
Abschlussarbeit
\linebreak[4]
\linebreak[4]
zur Erlangung des akademischen Grades:
\linebreak[4]
\linebreak[4]
\textbf{Bachelor of Science (B.Sc.)}
\linebreak[4]
\linebreak[4]
an der
\linebreak[4]
\linebreak[4]
Hochschule f\"ur Technik und Wirtschaft (HTW) Berlin
\linebreak[4]
Fachbereich 4: Informatik, Kommunikation und Wirtschaft
\linebreak[4]
Studiengang \textit{Angewandte Informatik}
\linebreak[4]
\linebreak[4]
\linebreak[4]
1. Gutachter: Titel akademischer Grad Vorname Nachname\linebreak[4]
2. Gutachter: B.Sc. Moritz Wachter\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Eingereicht von Jonathan Neidel [573619]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Datum

\end{center}
\end{titlepage}
\newpage

\thispagestyle{empty}
\vspace*{2.2cm}
\noindent
{\Huge Danksagung}\\
\vspace*{1.6cm} \\

% Kopfzeilen (automatisch erzeugt)
%\pagestyle{headings}
[Text der Danksagung]

% Seite mit Abstracts
\newpage
\thispagestyle{empty}
\section*{Zusammenfassung}
[Text der Zusammenfassung]

\section*{Abstract}
[Summary of the thesis]


\clearpage
%Seite 1
\pagenumbering{roman}
%\setcounter{page}{1}

\tableofcontents
.
\newpage

\pagenumbering{arabic}
% \setcounter{page}{1}   % setzt Seitenzaehlung auf 1

% \fbox{\parbox{\linewidth}{
% }}

% \\
% \linebreak[4]

% \footnote{Erg\"anzende Informationen k\"onnen Sie auch in eine Fu"snote auslagern. Hier wird die Fu"snote dazu genutzt, um Ihnen bei Interesse am Thema Zitation vertiefende Quellen (z.B. \autocite{balzert2011} oder \autocite{franck2013}) anzubieten.}

% \begin{table}
% \caption{\"Ubersicht: Untersuchte Steinl\"ause}
% \centering
% \begin{tabular}{llr}
% \toprule
% \multicolumn{2}{c}{Untersuchte Objekte mit Lokation des Habitats} \\
% \cmidrule(r){1-2}
% ID (nickname) & Ort & Gr\"o"se/L\"ange (in mm) \\
% \midrule
% 1 (Rosalinde) & Berlin, Mauerpark & $1.4$ \\
% 2 (Devil in disguise) & Brandenburg, BER-Airport & $2.8$ \\
% 3 (Hannes) & Berlin, Olympia-Stadion & $2.1$ \\
% 4 (Her Majesty) & Berlin, Humboldt-Forum & $2.0$ \\
% \bottomrule
% \end{tabular}
% \end{table}

\chapter{Einleitung}
\section{Hintergrund der Arbeit}
% [Beschreibung des groben Kontextes der Arbeit; im Detail sollten Sie dies im Grundlagenteil darstellen]

Die Kommandozeile und darauf basierende Applikationen bergen das Potential für Produktivitätssteigerungen im Vergleich zu GUI Applikationen, vorrausgesetzt der Nutzer weiß mit dieser umzugehen. % TODO: Citation needed


\section{Problem- und Zielstellung (Scope)}
% [Beschreibung der Problemstellung sowie der sich daraus ergebenden Teilprobleme,-ziele und Forschungsfrage(n), welche Sie mit Ihrer Arbeit addressieren]

Die Kommandozeile und seine Applikationen sind für Personen welche mit dieser Umgebung nicht vertraut sind schwer benutzbar. % TODO: Citation needed
Einflussfaktoren dafür sind:

\begin{enumerate}
  \item Fehlendes Wissen über das Ökosystem (wie werden Applikationen gestartet, wie findet man Hilfe, Verständnis grundsätzlicher Werkzeuge fehlt)
  \item Applikationen sind nicht für Neulinge konzipiert
\end{enumerate}

Problemstellung dieser Arbeit soll das zweite der gelisteten Probleme sein: Das Zusammentragen und Evaluieren der Faktoren welche Kommandozeilen Applikation für Neulinge zugänglich machen. Oder konkreter als Forschungsfrage definiert:

\bigbreak

\fbox{\parbox{\linewidth}{
Welche Faktoren sind für die Konstruktion einer Command-Line basierten App zu
beachten um diese für Personen, welche nicht mit dem Terminal vertraut sind,
zugänglich zu machen?
}}

\section{Aufbau der Arbeit}
% [Beschreibung des Aufbaus der Arbeit]

Die Arbeit gliedert sich in folgende drei Hauptteile:

\begin{enumerate}
  \item \textbf{Erarbeitung von Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen Interfaces}:
    \smallbreak
    In Literaturrecherche werden Methoden zusammengetragen und formuliert.
    Diese sind - wie im Sinne des Wortes Methode (``Weg zu etwas hin'' laut \cite{duden_methode}) - deskriptiv und beschreiben wie ein gewünschter Effekt zu erzielen sein soll.
    \begin{enumerate}
      \item \textbf{Probleme mit Kommandozeilen Interfaces}:
        \smallbreak
        Es werden zuerst Probleme, welche die Nutzung von Kommandozeilen Interfaces erschweren erläutert.
      \item \textbf{Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen Interfaces}:
        \smallbreak
        Methoden werden formuliert und wie diese zuvor geschilderte Probleme adressieren.
    \end{enumerate}

  \item \textbf{Implementation einer Anwendung auf Basis der erarbeiteten Methoden}:
    \smallbreak
    Gesammelte Methoden werden in der Implementation einer App demonstriert.
    Die App ist überschaubar komplex und adressiert das manuelle Festhalten von Arbeitsstunden.
    \begin{enumerate}
      \item \textbf{Anforderungsanalyse}:
        \smallbreak
        Zuerst werden die von der App zu erfüllenden Anforderungen erörtert.
      \item \textbf{Implementation der App unter Berücksichtigung gesammelter Methoden}:
        \smallbreak
        Es werden die Anforderungen unter Beachtung ermittelter Methoden implementiert.
    \end{enumerate}

  \item \textbf{Evaluation der implementierten Anwendung}:
    \smallbreak
    Die App wird von mit dem Anwendungsfall vertrauten Kommandozeilen Einsteigern getestet.
    Und Anhand einer Umfrage evaluiert.
    \begin{enumerate}
      \item \textbf{Umfragengestaltung}:
        \smallbreak
        Es wird die Umfrage gestaltet.
      \item \textbf{Auswertung}:
        \smallbreak
        Ergebnisse der Umfrage werden ausgewertet.
    \end{enumerate}
\end{enumerate}

\chapter{Grundlagen und Definitionen}
% [Beschreibung des Kontextes der Arbeit mit allen durch die Problemstellung tangierten Bereichen, Methoden, Theorien, Erkenntnissen, Technologien, ... ]

% TODO: CLI, how did we get here, <-> GUI

% TODO: citation needed, multiple tech definitions
\textbf{Kommandozeilen Interface}: (Engl. command-line interface) oft auch als \textbf{CLI} abgekürzt

Die Kommandozeile nimmt eine Anfrage, in Form von einer Zeile Text, entgegen und antwortet darauf.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{mullvad-status.png}
  \caption{Ändern und Überprüfen des VPN Standorts in der Linux Kommandozeile mit dem \codeinline{mullvad} CLI}
  \label{fig:mullvad-status}
\end{figure}

Die Kommandozeile existiert in zwei Ausprägungen: dem Betriebssystem CLI, auch
als Shell bekannt (siehe die Linux Shell in Abbildung \ref{fig:mullvad-status})
oder der Kommandozeile einer Anwendung (siehe die Node.js Kommandozeile in
Abbildung \ref{fig:node-calc}).

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{node-calc.png}
  \caption{Durchführung einer Berechnung in der Node.js Kommandozeile}
  \label{fig:node-calc}
\end{figure}

\cite{Spolsky_2001} beschreibt neben der CLI noch zwei weitere Terminal Interfaces welche sich aus diesem entstanden sind:
\\
\textbf{Interaktive CLI}: Ein ``question and answer model'' \parencite[42]{Spolsky_2001} der Kommandozeile, wo der Nutzer mittels Fragen, auf die eine Antwort erwartet wird, entlastet wird. Mehr dazu in Kapitel \ref{chap:interactive}.
\\
\textbf{Menu-driven CLI}: auch als Ncurses CLI bekannt. Das Menü-basierte CLI ähnelt dem GUI indem

% Vergleich zu GUI
% function-orient vs object-oriented vgl. nielson1993

\textbf{Flagge}: Zusammen mit Argumenten sind Flaggen der primäre Weg für eine
CLI App um Werte von Nutzern entgegen zu nehmen \parencite{12factor}. Sie
existieren meist in langer, erkennbar durch die \codeinline{--} am Anfang, oder
kurzer Version, mit nur einem \codeinline{-} und meist dem Anfangsbuchstaben der
Langversion.

\begin{code}
\begin{shellcode}
grep --file FILE
grep -f FILE
\end{shellcode}
\captionof{listing}{Kurze und lange Flaggen am Beispiel equivalenter grep Aufrufe}
\medskip
\end{code}

In dem Beispiel mit grep wird von \codeinline{--file FILE} eine Datei mit
Mustern zum Vergleichen übergeben. Bei mehreren Flaggen ist die Reihenfolge
egal.

\begin{code}
  \begin{shellcode}
  grep --ignore-case
  grep -i
  \end{shellcode}
  \captionof{listing}{Ein Beispiel von Boolean Flaggen}
  \medskip
\end{code}

Die \codeinline{--ignore-case} Flagge von Grep ist eine Boolean Flagge. Meist
wird durch Abwesenheit eine Verneinung ausgedrückt und durch Anwesenheit
\codeinline{true}. Boolean Flaggen übergeben keine Werte sondern ändern das
Verhalten der App. Im Falle von grep's \codeinline{ignore-case} existiert
zusätzliche noch eine \codeinline{--no-ignore-case} Flagge, falls der Nutzer
explizit sein möchte. Kurze Booleanflaggen ermöglichen auch konstrukte
wie dieses: \codeinline{tar -xzf file.tgz}. Es werden die Booleanflaggen
\codeinline{-x}, \codeinline{-z}, wie auch die normale \codeinline{-f FILE}
Flagge kombiniert.

\textbf{Argument}: Argumente erlauben es der CLI Werte von Nutzer anzunehmen.

\begin{code}
  \begin{shellcode}
mv SOURCE DEST
  \end{shellcode}
  \captionof{listing}{Manual Auszug von mv, in seiner simpelsten Form}
  \medskip
\end{code}

Anders als bei Flaggen ist Reihenfolge ausschlaggebend. Beim obigen
\codeinline{mv} Programmaufruf ist das erste Argument die Ausgangsdatei und das
zweite die Zieldatei. Die eigentlichen Dateien unterscheidet nichts, einzig die
Reihenfolge beschreibt die Absicht.


% TODO: Pipe, Interaktive, Menu -> alternative Wege zur Übergabe von Werten

%%% Methoden
\chapter{Methoden zur Absenkung der Nutzungsschwelle}
% TODO: intro here

\section{Methodologie}
% [Beschreibung des geplanten Vorgehens(-modells) zur Lösung der Problemstellung; umfasst u.a.:

Die Artefakte dieses Kapitels sind die folgenden:
\begin{enumerate}
  \item Eine Auflistung von Problemen welche den Umgang mit Kommandozeilen Interfaces erschweren
  \item Eine Auflistung von Methoden, welche diese Probleme adressieren
\end{enumerate}

In Literaturrecherche sollen Probleme erschlossen werden, als auch die dafür -
möglicherweise vielfach - vorliegenden Lösungsansätze. Welche dann, unter Bezug
auf das Problem, als Methoden formuliert dokumentiert werden sollen.
\\
Die Formulierung als Methode soll dabei den Lösungsansatz so beschreiben das
dieser anwendbar ist. Dies ist u.a. erforderlich da die Methoden im nächsten
Schritt angewandt werden sollen.

\section{Probleme mit Kommandozeilen Interfaces}

Es folgen, in nicht priorisierter Reihenfolge, Probleme welche die
Nutzungsschwelle von Kommandozeilen Interfaces erhöhen, d.h. diese weniger
zugänglich.
\\
Diese bestmöglich zu adressieren sollte zu einer Absenkung der Nutzungsschwelle
und damit besser zugänglichen Applikationen führen.

\subsection{Erinnern von Kommandos}

Das Problem des Erinnern von Kommandos (engl. Command recall) beschreibt das
Nutzer sich bei Verwendung eines Programmes an dessen Namen, Kommandos und
Parameter erinnern müssen \parencite{Raskin_2008}.

\fbox{\parbox{\linewidth}{
  \label{prob:command-recall}
  \textbf{Problem~\ref{prob:command-recall}}: Es muss sich an Programmname, Kommandos und Parameter erinnert werden.
}}

Um dieses allgemeine Problem zu adressieren wird es sind kleinere Teilprobleme
aufgespalten.

\medskip

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{empty-prompt.png}
  \caption{Die Shell bietet nichts an, ohne ein Programm zu kennen passiert nichts.}
\end{figure}

\cite{Gentner_1996} beschreibt auch den Fakt das es keinen einfachen Weg zum
Auffinden von Programmen gibt.
\\
Der Nutzer muss also den Namen des Programmes kennen um dieses zu nutzen.

\smallskip

Unter der Annahme den Names des Programmes zu kennen, geht es nun darum einen
Programmaufruf mit Kommandos und Parametern zusammen zu bauen.
Hierzu können verschiedene Szenarien betrachtet werden.
Der Nutzer:

\begin{enumerate}
  \item hat Kommandos und Parameter auswendig gelernt
  \item baut den Programmaufruf mit Hilfe der Dokumentation zusammen
  \item fügt den Programmaufruf (mit copy-paste) ein
  \item ruft das das Programm indirekt auf (über ein Script oder Alias)
\end{enumerate}

Diese Szenarien sind aber alle nicht ideal:

\medskip

Das 1. Szenario gilt nur mit dem Programm vertraute Nutzer. Und selbst diese
vergessen mit der Zeit. % TODO: citation needed, vergessen

\medskip

Szenario Nummer 2. ist zeitintensiv für den Nutzer. Auch gilt die Annahme das
Dokumentation existiert und das der Nutzer mit dieser umgehen kann.

\medskip

Für Szenario Nummer 3. muss der Nutzer von irgendwo kopieren, die Quelle ist
hier entweder auch die Dokumentation oder externe Portale wie Foren oder
Stack Overflow. In der Dokumentation musst der Programmaufruf auch erstmal
gefunden werden. Und die externen Portale sind für den Bau des Interfaces nicht
verlässlich.

\medskip

Szenario Nummer 4. gilt nur für erfahrene Nutzer die schon mit der Shell
vertraut sind.

\medskip

Es gibt auch Mischformen, wie das der Nutzer Kommando aber nicht Parameter kennt
und dieses nachschaut, diese sind aber in der Betrachtung zu vernachlässigen, da
die Kritiken an den Reinformen auch für sie gelten.

\subsection{Syntax und Semantik}

``Commands and associated parameters must be typed, maintaining the correct
semantic content and syntactic form.'' \parencite[184]{Westerman_1997}

\cite{Gentner_1996} beschreibt die Kommandozeile auch als sehr starr und wenig
Tolerant gegenüber imperfekter Syntax.

\fbox{\parbox{\linewidth}{
  \label{prob:syntax-semantik}
  \textbf{Problem \ref{prob:syntax-semantik}}: Die richtige Syntax and Semantik muss gewährleistet werden.
}}

\bigskip

Ein Beispiel für fehlerintolerante Syntax am Beispiel von \codeinline{grep}.
Die man page beschreibt die Syntax: \codeinline{grep [OPTION...] PATTERNS [FILE...]}.
Beim schnell-geschehenen Vertauschen von \codeinline{FILE} und \codeinline{PATTERNS}:

\begin{code}
  \begin{shellcode}
grep ./file "[a-z]{3}"
/bin/grep: [a-z]{3}: No such file or directory
  \end{shellcode}
  \captionof{listing}{Fehlerhafte Kommando Syntax bei grep}
  \medskip
\end{code}

Der Bedeutungsgehalt von Kommandos kann an diesem Beispiel dargestellt werden:

\begin{code}
  \begin{shellcode}
git remote add [..]
git add remote
  \end{shellcode}
  \captionof{listing}{Kommando Semantik am Beispiel von git}
  \medskip
\end{code}

Das Kommando \codeinline{git remote} ist zum verwalten von `tracked repositories'.
\codeinline{git add} markiert eine Datei für den nächsten `commit'.
Je nach Kontext haben \codeinline{add} und \codeinline{remote} eine andere Bedeutung.
\codeinline{git remote add} fügt eine neue `repository' hinzu, \codeinline{git
add remote} markiert aber eine Datei mit dem Namen \codeinline{./remote} für den
nächsten `commit'.

\section{Adressierung der Probleme durch Weiterentwicklungen}

Ziel dieser Arbeit ist es Methoden zur Adressierung dieser fundamentalen
Probleme innerhalb der Form der Kommandozeile zu beschreiben.

Die meisten Abhandlungen über das Angehen dieser Probleme versuchen aber aus
dieser Form von Interface auszubrechen.

Historisch wurde die grafische Benutzeroberfläche als Lösung für die Probleme der
CLI gesehen (\cite{Norman_2007}). % TODO: other cite

Laut \cite{nielson1993} vollzog sich damit ein Wechsel von `function-oriented',
der in der Kommandozeile typischerweise vorhandenen Verb-Nomen Struktur (z.B.
\codeinline{rm file}), hin zu der Objekt-orientierten GUI, dem Auswählen des
Objektes und dann der Aktion welche darauf angewandt werden soll (z.B. Datei in
den Papierkorb ziehen.)

% TODO: modern answer engine, shared DNA with CLI
 % \cite{Norman_2007}

% TODO: human language, über Syntax hinaus, menschliche Sprache verstehen
% Raskin_2008

% Conclusions von seneviratne2008new lesen

% TODO: visual cli a la Glaser et al. (1995), see seneviratne2008new

\section{Gesammelte Methoden}
% Methoden beziehen sich direkt auf ein Problem welches adressiert werden soll.

\newcommand{\methbox}[2]{
  \fbox{\parbox{\linewidth}{
    \label{meth:#1}
    \textbf{Methode~\ref{meth:#1}}: #2
  }}
}
\newcommand{\methref}[1]{
  Methode~\ref{meth:#1}
}

Anders als erhofft gestaltete sich die Recherche nach Methoden zur Absenkung
der Nutzungsschwelle als schwierig da, wie bereits angesprochen, das GUI oder
eine andere Form von Nutzerinterface oft als Lösung für die Probleme von
Kommandozeilen angeführt wird.

% Konkrete Handlungsanweisungen, wie bei \cite{12factor} und
% \cite{nagarajan2018}, halten sich nicht exakt

% TODO: ...

%  philosophie/prinzipien

\subsection{Interaktive CLI}
% TODO: move this section into definitions

Als Interaktive CLI ist eine solche bekannt die dem Nutzer nach und nach Fragen
stellt, ähnlich einem Formular. Wie bei einem Formular kann neben Freitext kann
dem Nutzer mit Radiobuttons (auswählen von einer Option aus einer Liste) oder
Checkboxen (auswählen mehrerer Optionen aus einer Liste) zum auswählen. % TODO: fix

% TODO: screenshot mit Q&A format

% TODO: extend, reference sources
% bland2007design, Gentner_1996

\subsubsection{Interaktive Frage bei fehlendem Parameter}

% TODO: vgl. Command recall
Man stelle sich folgendes Szenario vor. Eine CLI hat ein Kommando welches einen Parameter erfordert.
Normalerweise erfolgt beim Weglassen der Übergabe dieses Parameters eine Fehlermeldung welche einen Hinweis darauf gibt.

\begin{code}
  \begin{shellcode}
mullvad relay set location

error: The following required arguments were not provided:
    <country>

USAGE:
    mullvad relay set location <country> [ARGS]

For more information try --help
  \end{shellcode}
  \captionof{listing}{Fehlermeldung bei fehlendem Parameter in mullvad (VPN) CLI}
  \medskip
\end{code}

Die CLI weiß aber bereits was der Nutzer tun möchte und könnte anstatt der
Fehlermeldung einen Prompt geben welcher den Nutzer nach den fehlenden
Parametern fragt \parencite{12factor} oder, je nach Kontext, diesem sogar eine
Liste von Vorschlägen geben, um daraus auswählen. Dem Nutzer wird erspart sich
mit der richtigen Syntax und den Vokabeln auseinander zu setzen.

\methbox{interactive_missing_param}{Bei fehlendem Parameter soll interaktiv nachgefragt werden.}

\begin{code}
  \begin{shellcode}
mullvad relay set location
Enter location country code:
  \end{shellcode}
  \captionof{listing}{Prompt welcher direkt nach fehlendem Parameter fragt}
  \medskip
\end{code}

Fairerweise ist zu bemerken das die mullvad CLI dies auch an anderer Stelle
so handhabt, so fragt die CLI bei \codeinline{mullvad account login} nach der
fehlenden Accountnummer.

Negativ an dieser Methode wäre das der Nutzer nicht im gleichen Maße auf die
Möglichkeit einer komplexeren Verwendung des Kommandos hingewiesen wird (so
nimmt das mullvad Kommando aus obigem Beispiel nicht nur Landes- sondern auch
Stadt- und Hostkennungen). Außerdem wird der Programmaufruf ohne den Parameter
in der Shell History gespeichert, was bedeutet bei das bei zurückgehen zu dem
Aufruf der fehlende Parameter immer noch fehlt und ergänzt oder erneut über den
Prompt übergeben werden muss. % TODO: shorten

Beide Punkte sind aber für Einsteiger eher zu vernachlässigen.

\subsection{Menü oder TUI}

% TODO: screenshot
Das Menü oder auch `Text-based user interfaces' ähneln dem GUI dadurch das der
Nutzer seine Optionen visuell präsentiert bekommt und daraus ausgewählen kann.
\\
Da es aber wie die CLI in Terminal lebt werden auch zum darstellen des Menüs
nur Textelemente verwendet. Zur Implementation wird oft die ncurses Bibliothek
verwendet.

\bigskip

Im einem Experiment von \cite{Westerman_1997} hatte das Menü-basierte
Interface, für manche Nutzergruppen, unsignifikant bessere Performance als
ein Kommandozeilen Interface. Auch wurde bei freier Wahl das Menü über alle
Nutzergruppen hinweg doppelt so häufig verwendet.

\methbox{menu}{Biete ein Menü-Interface an.}

% TODO: move and complete

\subsection{Autovervollständigung zum Vorschlagen und Vervollständigen von Kommandos/Flaggen}

Auto-completion in der Kommandozeile beschreibt das Verhalten das bei drücken der
(normalerweise) `TAB' Taste etwas vervollständigt wird.

In der Shell funktioniert dies etwa für Programmnamen und die Pfade von Dateien:
\begin{code}
  \begin{shellcode}
wg # Nutzer drueckt TAB
wget

cat ./note # Nutzer drueckt TAB
cat ./notes.md
  \end{shellcode}
  \captionof{listing}{Autovervollständigung in der Shell}
  \medskip
\end{code}

Bei Programmen kann dies, neben der Vervollständigung von Dateipfaden, auch
Kommandos und Flaggen umfassen.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{mullvad-autocomplete.png}
  \caption{Bei mullvad's CLI werden nach dem drücken von `TAB' mögliche Kommandos aufgelistet}
  \label{fig:autocomplete}
\end{figure}

% TODO: Vorschlagen beschreiben

\methbox{autocomplete}{Dem Nutzer sollte innerhalb der App Autovervollständigung zu verfügung gestellt werden.}

Auto-completion adressierte beide Probleme welche das CLI mit sich bringt, durch
das Vorschlagen und Vervollständigen erleichtert das Erinnern des gesuchten
Kommandos. Und dadurch das nur valide Kommandos vorgeschlagen werden ist das
einhalten von Syntax- und Semantikregeln erleichtert. Auch profitiert der Nutzer
von Kontext-bezogenen Beschreibungen.

In \cite{dutta} geht der Author sogar noch einen Schritt weiter und empfehlen
das automatische Vorschlagen aller Flaggen und Argumente für ein Kommando,
sodass der Nutzer sich nicht mal anschauen muss was für das Kommando benötigt
wird. So wie vom Author beschrieben ist dies aber nicht in der Shell möglich,
sondern müsste meiner Einschätzung nach eine eigene Kommandozeilen Umgebung
gebaut werden, was nicht im Sinne der Zielstellung dieser Arbeit liegt.

\subsection{Relevante Standardwerte}

Relevante Defaults sind nicht Kommandozeilen spezifisch, können dort aber
wichtiger sein als in grafischen Anwendungen.
\\
Dem Nutzer werden die Möglichkeiten eben nicht zur Auswahl gestellt und dieser
klickt die gewünschte Option an. Sondern ist das Auflisten der Möglichkeiten
i.d.R. ein separater Schritt, losgelöst von der eigentlich beabsichtigten Aktion
(z.B. siehe Abbildung \ref{fig:defaults-demo} oder das mit \codeinline{ls -d}
zuerst die verfügbaren Ordner aufgelistet, um sich dann mit \codeinline{cd
ORDNER} in einen von diesen hineinzubewegen,auch .)
\\
Es greift wieder das fundamentale Problem des `Command Recall' (vgl. Problem
\ref{prob:command-recall}). Den Schritt des Auflistens der Möglichkeiten
(ähnlich wie das Auflisten von möglichen Kommandos) ist ein extra Schritt, außer
der Nutzer kann sich an die gewünschte Option erinnern.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{defaults-demo.png}
  \caption{Der erforderte Parameter in dieser Literaturverwaltung ist einer Liste zu entnehmen.}
  \label{fig:defaults-demo}
\end{figure}

\bigskip

\methbox{relevant_defaults}{Falls möglich haben Argumente relevante Defaultwerte.}

Dem Nutzer relevante Standardwerte zu geben erlaubt es diesem weniger
Argumente an die CLI App übergeben zu müssen. Es gibt weniger Fehlermeldungen
die den Nutzer zurückweisen, weil dieser etwas vergessen hat.

Es ist aber auch elementar die Nutzung dieser Standardwerte zu kommunizieren.
Damit der Nutzer von ihnen nicht überrascht wird.

% TODO: describe 12 Factor methods
% https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46
\subsection{Flaggen anstatt Argumenten}
% 2. Prefer flags to args

Sobald ein Kommando mehr als ein Argument annimmt, biete sich die Gelegenheit
die für Argumente relevante Reihenfolge durcheinander zu bringen (vgl. Command
Recall und Syntax % TODO: fix formating

). \cite{12factor} empfiehlt deshalb bei zwei oder mehr Argumenten Flaggen zu
verwenden. Das ist etwas mehr Aufwand zum Schreiben aber die Reihenfolge als
Fehlerfaktor (vgl. Syntax

) und Flaggen können nun auch mittels Autovervollständigung vorgeschlagen werden
(vgl. \methref{autocomplete}).

\methbox{flags_over_arguments}{Wenn zwei oder mehr Argumenten erforderlich sind nutze stattdessen Flaggen.}

Dies trifft vorallem zu wenn wenn bei dem Kommando schon andere Werte über
Flaggen übergeben werden.

\begin{code}
  \begin{shellcode}
oraclett project add INTPD999DXD --taskDetail "01 - Career development"
oraclett project add --project INTPD999DXD --taskDetail "01 - Career development"
  \end{shellcode}
  \captionof{listing}{Argument ersetzt durch Flaggen: vorher und nachher}
  \medskip
\end{code}

Außen vor sind auch Kommandos welche eine variable Anzahl an Argumenten nehmen,
Beispielsweise \codeinline{rm file1 file2 file3}, weil es sich bei diesen nicht
um verschiedene Typen von Argument handelt \parencite{12factor}.

\subsection{Unterstützung aller Versions- und Helpflaggen}
% 3. What version am I on? -> aliases, get the user what they are looking for

Alle Apps biete eine Hilfs- und eine Versionsseite. Nutzer haben ihre Präferenzen
wenn es darum geht welche Flagge sie verwenden um diese angezeigt zu bekommen.

\begin{code}
  \begin{shellcode}
app -h
app --help
app help

app -v
app -V
app --version
app version
  \end{shellcode}
  \captionof{listing}{Gängige Varianten der Hilfs- und Versionsflaggen}
  \medskip
\end{code}

Laut \cite{12factor} sollten möglichst alle in die App eingebaut sein. So kann
vermieden werden das ein Nutzer nicht das angezeigt bekommt wonach er sucht.

\medskip

\methbox{support_all_help_version}{Unterstütze alle gängigen Formen der Versions- und Helpflaggen.}

\bigskip % TODO: necessary?

\newcommand\checkmark{\ttfamily{\char"2611}}
\newcommand\cross{\ttfamily{\char"2610}}
\begin{table}[h!]
  \begin{center}
    \caption{Unterstützte Varianten von Hilfs- und Versionsflaggen bei einer Stichprobe von 15 Programmen}
    \label{tab:help_version}
    \begin{tabular}{l | c c c | c c c c}
      Programm & \codeinline{-h} & \codeinline{--help} & \codeinline{help} & \codeinline{-v} & \codeinline{-V} & \codeinline{--version} & \codeinline{version} \\
      \hline
git & \checkmark & \checkmark & \checkmark & \checkmark & \cross & \checkmark & \checkmark \\
node & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
mullvad & \checkmark & \checkmark & \cross & \cross & \cross & \cross & \checkmark \\
grep & \cross & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
zathura & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
tsp & \checkmark & \cross & \cross & \cross & \checkmark & \cross & \cross \\
pubs & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
ffmpeg & \checkmark & \checkmark & \cross & \cross & \cross & \cross & \cross \\
systemctl & \checkmark & \checkmark & \cross & \cross & \cross & \checkmark & \cross \\
pacman & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
make & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
synctex & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
curl & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
ansible & \checkmark & \checkmark & \checkmark & \cross & \cross & \checkmark & \cross \\
nvim & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
      \hline
      Summe & 14 & 14 & 3 & 7 & 5 & 12 & 3 \\
    \end{tabular}
  \end{center}
\end{table}

In meinem unrepresentativen Stichprobe stellte sich heraus das
\codeinline{-h} und \codeinline{--help} eigentlich überall funktionieren. Mit
\codeinline{--version} bekommt man in den meisten Fällen auch was man will. Aber
wenn dies nicht zum Ziel führt kommt es zum durcheinander und man muss sich
durchprobieren. Bei ffmpeg gibt es sogar nur eine krude \codeinline{-version}
Flagge.

Am wenigsten verbreitet sind \codeinline{help} und \codeinline{version}, welche
aber auch etwas außen vor sind, weil das erste Argument bei vielen Programmen
eine Input Datei bezeichnet. Aber soweit es die App erlaubt, vor allem bei Apps
mit mehreren Kommandos, sollten auch diese Varianten unterstützt werden.

% \subsection{Rechtschreibfehler }
% % closer to natual language
% match both project/projects
%
% Die Kommandozeile ist in der Regel sehr strikt  % TODO: ref syntax
% und Rechtschreibfehler führen zu Fehlermeldungen.
% Deswegen empfiehlt \cite{clig} das, wenn man sich denken kannst was der Nutzer
% meint, dies vorgeschlagen werden soll.
%
% \begin{code}
%   \begin{shellcode}
% heroku pss
%  ›   Warning: pss is not a heroku command.
% Did you mean ps? [Y/n]:
%   \end{shellcode}
%   \captionof{listing}{Beispiel eines Vorschlags den Rechtschreibfehler zu korrigieren}
%   \medskip
% \end{code}
%
% http://www.catb.org/~esr/jargon/html/D/DWIM.html
% Nach der Philosophie von `Do What I Mean' \parencite{DWIM} hingegen werden
% Fehler direkt ohne Nutzerfeedback ausgebessert. Was natürlich schneller ist und
% den Nutzungsflow nicht unnötig unterbricht, aber auch zu den in \cite{DWIM}
% beschriebenen `notorious incident[s]' führen.
% --camelCase --with-dashes: https://uxdesign.cc/user-experience-clis-and-breaking-the-world-baed8709244f

\subsection{Menschliche Sprache als Input annehmen} % TODO: rename, make it less general/grandiose

\cite{Raskin_2008} und \cite{Norman_2007} sprechen über die nächste Evolution
des User Interfaces als eine Art Kommandozeile basierend auf menschlicher
Sprache.

Auch wird die Kommandozeile nicht mehr nur als Scripting Platform sondern als
`human-first [..] text-based UI' gesehen \parencite{clig}.

% Da liegt es nahe innerhalb der Einschränkungen des CLI trotzdem zu versuchen
% menschliche Sprache zu verarbeiten.

% -> human readable (relative) dates

\chapter{Bauen}
\section{Anforderungsanalyse}
% [Beschreibung der Erhebung, Granularisierung und Priorisierung der zu Grunde liegenden Anforderungen]

Die zu bauende Anwendung wurde konzipiert nicht zu trivial - um genug
Spielraum im Interface Design zuzulassen - aber auch nicht zu komplex - um die
Umsetzbarkeit zu gewährleisten - zu sein.

\subsection{Konzept}
\subsubsection{Problem}

Bei Endava werden die Arbeitsstunden über ein Oracle System festgehalten. Dieses
glänzt nicht in Usability, es führt aber kein Weg dran vorbei.

% TODO: screenshot best case

Das System funktioniert so, dass ein mal wöchentlich die Zeiten der vergangen
Woche abgegeben werden müssen. In diesen Timecards wird angegeben an welchen
Wochentagen man wie viele Stunden an welchem Projekt gearbeitet hat. Bei einem
Projekt und 40 Stunden Woche ist das ausfüllen trivial. Aber sobald man seine
Zeit zwischen mehreren Projekten mit schwankender Stundenzahl aufteilt wird
es komplizierter. Außerdem wird teils gefordert sich Notizen zu machen woran
gearbeitet wurde. Zusammengenommen heißt dies: täglich müssen Dinge bei Oracle
eingetragen werden.

% TODO: screenshot realistic case

\subsubsection{Lösungsansatz}

Die entworfene Lösung ist eine Kommandozeilen App welche das tägliche loggen der
Arbeitszeiten, und Notizen woran gearbeitet wurde, vereinfacht. Und diese Daten
dann zum wöchentlichen Übertragen in Oracle in strukturierter Form ausgibt.
Dadurch wird erreicht nur das erforderliche Minimum der Zeit mit Oracle zu
verbringen, dessen Workflow im übrigen auch am besten funktioniert wenn alles in
einem Rutsch erledigt wird.
\\
Weil es den Rahmen sprengen würde, ohne dem Thema dienlich zu sein, wurde davon
abgesehen die CLI an ggf. bestehende Oracle APIs anzubinden.

\subsection{Anforderungen}

Die Anforderungen wurden in Form von User Stories festgehalten. Erhoben wurden
diese durch den Author in Analyse der eigenen Nutzungsmuster mit Oracle,
abgeglichen in Rücksprache mit anderen Mitarbeitern.

\begin{enumerate}
  \item \textbf{Verwaltung von Projekten}:
    \begin{enumerate}
      \item Als Nutzer möchte ich einen Projekt Schlüssel hinzufügen.
      \item Als Nutzer möchte ich einem Projekt Schlüssel ein oder mehrere Task Details anfügen.
      \item Als Nutzer möchte ich die Projekt Schlüssel sowie deren Task Details aufgelistet sehen.
      \item Als Nutzer möchte ich Projekt Schlüssen und Task Details anpassen oder löschen.
    \end{enumerate}
  \item \textbf{Arbeitszeit loggen}:
    \begin{enumerate}
      \item Als Nutzer möchte ich meine Arbeitsstunden an einem Tag für eine Project Code-Task Detail Kombination loggen.
      \item Als Nutzer möchte ich die geloggten Arbeitsstunden einer gegebenen Woche einsehen.
      \item Als Nutzer möchte ich geloggte Arbeitsstuden anpassen oder löschen.
    \end{enumerate}
  \item \textbf{Verwaltung von Arbeitsnotizen}:
    \begin{enumerate}
      \item Als Nutzer möchte ich etwas festhalten an dem ich an einem Tag gearbeitet habe.
      \item Als Nutzer möchte ich meine Notizen für einen Tag bearbeiten oder löschen.
    \end{enumerate}
  \item \textbf{Report Generierung}:
    \begin{enumerate}
      \item Als Nutzer möchte ich einen Report für eine gegebene Arbeitswoche generieren, um die Daten in Oracle zu übertragen.
    \end{enumerate}
\end{enumerate}

Diese User Stories sollen einen Eindruck über die Anforderungen der App
und deren Komplexität vermitteln. Das Bauen der App steht aber nicht im
Vordergrund, weshalb u.a. hier die Akzeptanzkriterien der User Stories,
Implementationsdetails wie Datenpersistierung, etc. nicht weiter beschrieben
werden.

\section{Implementation}
\subsection{Fundament}

Das Fundament der App stellen die zugrundelegenden technologischen Aspekte dar,
welche nicht oder nur indirekt die Nutzbarkeit, und damit den Fokus der Arbeit
betreffen.

Node.js wurde als Programmiersprache gewählt, weil der Author damit vertraut
war, eine vielzahl von Liberies zum Bauen von CLI's existieren und der
Paketveröffentlichungsprozess mit npm relativ simpel ist. Weiterhin wurden noch
Typescript - für Typisierung - und Eslint - für gleichmäßigen Code Style -
verwendet.

\subsection{Libraries}

Ein Überblick über die Libraries welche für das Bauen des Interfaces und die
Umsetzung der Methoden relevant waren.

\subsubsection{oclif}

``oclif is an open source framework for building a command line interface
(CLI) in Node.js. Create CLIs with a few flags or advanced CLIs that have
subcommands.'' \parencite{oclif}

oclif biete ein System um ohne viel Boilerplate Kommandos zu bauen, dessen
Flaggen und Argumente zu beschreiben und dann eigene Businesslogik auszuführen
(siehe Abbildung \ref{fig:oclif-list}.) Während oclif Kommando- und
Flaggenparsing, das generieren der Hilfsseite uvm. übernimmt.

\begin{figure} % TODO: redo, as listing?
  \centering
  \includegraphics[scale=0.5]{oclif-list.png}
  \caption{Beschreiben eines Kommandos in oclif am Beispiel des implementierten \codeinline{project list} Kommandos}
  \label{fig:oclif-list}
\end{figure}

Die Hierarchie von Kommandos wird über eine Strukurierung der Dateien erreicht (siehe nachstehendes Listing) und der Feinschliff wird noch per Konfiguration in der \codeinline{package.json} erreicht.

\begin{code}
  \begin{shellcode}
 src/commands
 ├── hours
 │   └── list.ts
 └── project
     ├── add.ts
     ├── edit.ts
     ├── list.ts
     └── remove.ts
  \end{shellcode}
  \captionof{listing}{Kommandohierarchie über Dateistruktur: Kommandos und deren Subkommandos}
  \medskip
\end{code}

% TODO: node noch andere libs, oclif warum gewählt? Verweis auf autocomplete

\subsubsection{Inquirer.js}

Inquirer stellt eine komplette Ansammlung an interaktiven % TODO: reference to earlier chapter
Fragetypen zusammen.

Neben einfachen Fragen wie danach Text einzugeben oder aus einer Liste
auswählen, gibt es auch eine Checkbox bei welcher mehrere Einträge einer
Liste gewählt werden können oder einen Prompt zu bearbeiten von Text im
\codeinline{\$EDITOR} (einer Shellvariable in welcher der Nutzer seinen
präferierten Texteditor einträgt).

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{inquirer-example.png}
  \caption{Ein Frage und Antwort Flow zum herausfinden was der Nutzer bearbeiten möchte}
  \label{fig:inquirer-example}
\end{figure}

\begin{code}
  \medskip
  \captionof{listing}{Code Beispiel zum Implementieren eines simplen \codeinline{inquirer list} Prompts}
  \begin{javascriptcode}
const { whatToEdit } = await inquirer.prompt( [ {
  type   : "list",
  name   : "whatToEdit",
  message: "What do you want to edit?",
  choices: [
    {
      name : "Project Name",
      value: "project",
    },
    {
      name : "Task Details (of a project)",
      value: "taskDetail",
    },
  ],
} ] );

// wird zu:

? What do you want to edit? (Use arrow keys)
> Project Name
  Task Details (of a project)
  \end{javascriptcode}
\end{code}

\subsection{Vorstellung der Implementierten Lösung}

% TODO: how does this chapter look?
% TODO: texts to disjointed?
% TODO: describe npm package

Es folgt eine grobe Vorstellung der Implementierten App. Nachgehend wird
noch einmal seperat auf die Implementation der Methoden zur Absenkung der
Nutzungsschwelle eingegangen.

\medskip

Der Name der App `oraclett' ist kurz für `Oracle time tracker'. Gewählt wurde
dieser weil er 1) kurz und prägnant als auch 2) mit Autovervollständigung leicht
zu finden ist. Intern ist die Platform zu festhalten der Arbeitszeiten als
`Oracle` bekannt, deshalb sollte der Name des Programmes mit \codeinline{oracle}
beginnen damit beim drücken von TAB dann zu \codeinline{oraclett}
vervollständigt wird. Andere in Erwägung gezogene Varianten waren
\codeinline{oracle-time-tracker} oder \codeinline{ott}.

\begin{code}
  \medskip
  \captionof{listing}{Das Hilfsmenu der CLI App}
  \label{code:oraclett-help}
  \begin{shellcode}
  \$ oraclett --help

  Oracle time tracker

  VERSION
    oraclett/0.0.0 linux-x64 node-v19.2.0

  USAGE
    \$ oraclett [COMMAND]

  TOPICS
    hours     Log working hours.
    note      Note down what you worked on.
    project   Add a project code.
    timecard  Generate a report for filling out timecards.

  COMMANDS
    autocomplete  display autocomplete installation instructions
    help          Display help for oraclett.
    timecard      Generate a report for filling out timecards.
  \end{shellcode}
\end{code}

Die Kommandos sind nach dem `noun verb' Prinzip \parencite{clig} strukturiert.
Auf das Nomen, in unserem Fall etwa die Stunden (\codeinline{hours}), folgt
ein Verb wie hinzufügen, bearbeiten, entfernen oder auflisten. Diese Verben
sind bei allen Kommandos einheitlich. Zu bearbeiten eines Projekt wird ebenso
\codeinline{edit} verwendet wie beim bearbeiten einer Notiz.

\begin{code}
  \label{code:hours-help}
  \begin{shellcode}
  \$ oraclett hours --help

  Log working hours.

  USAGE
    \$ oraclett hours COMMAND

  COMMANDS
    hours add     Log working hours.
    hours edit    Edit the logged hours interactively.
    hours list    List all projects.
    hours log     Log working hours.
    hours remove  Remove logged hours interactively.
  \end{shellcode}
  \captionof{listing}{Hilfsseite des `hours' Kommandos}
  \medskip
\end{code}

Die vorgesehene Nutzungsflow wäre wie folgt. Wenn man einem neuen Projekt
zugewiesen wird fügt man dieses \codeinline{oraclett} mit \codeinline{project
add} hinzu.
\\
Im normalen Arbeitsalltag würde man gearbeitete Stunden mit \codeinline{hours
add} festhalten. Auch Notizen dazu woran gearbeitet wurde würden im Moment
selbst mit \codeinline{note add} dokumentiert werden.
\\
Am Ende Arbeitswoche würde mit \codeinline{timecard} ein Report erstellt, dessen
Daten dann in das interne Oracle System übertragen werden. Womit die Woche
abgeschlossen wäre.
\\
Zum Verwalten oder Ausbessern der Daten im System gibt es jetzt noch die
\codeinline{edit} und \codeinline{remove} Subkommandos. Diese stehen falls
benötigt zur Verfügung, sind aber nicht teil des normalen Workflows.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{project-add.png}
  \caption{Interaktives hinzufügen eines Projektes.}
  \label{fig:project-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{project-list.png}
  \caption{Auflisten der im System vorhandenen Projekte.}
  \label{fig:project-list}
\end{figure}

Die Farben für verschiedene Daten sind einheitlich über alle `list' Kommandos.
So sind die Codes die Referenzcodes Projekte und `Task Details' Grün
bzw. Blau. Dies ist u.a. in den Abbildungen \ref{fig:project-list} und
\ref{fig:note-list} zu sehen. Notizen werden mit Gelb markiert, etwa auf der
Abbildung \ref{fig:note-list}. Und Stundenanzahl sowie Wochentage werden mit
Magenta hervorgehoben, wie zu sehen in Abbildungen \ref{fig:hours-list} und
\ref{fig:timecard}.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{note-add.png}
  \caption{Hinzufügen von Notizen auf interaktivem und normalem Wege.}
  \label{fig:note-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{note-list.png}
  \caption{Die Auflistung der Notizen einer gewählten Woche.}
  \label{fig:note-list}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{hours-add.png}
  \caption{Loggen von Stunden. Beim Weglassen von Flaggen werden diese interaktiv erfragt.}
  \label{fig:hours-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{hours-list-real.png}
  \caption{Auflistung der festgehaltenen Stunden.}
  \label{fig:hours-list}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{timecard-real.png}
  \caption{Ein die ganze Woche zusammenfassender Report, welcher in seiner Struktur dafür ausgelegt ist in die Web-Oberfläche des internen Tools übertragen zu werden.}
  \label{fig:timecard}
\end{figure}

\subsection{Anwendung gesammelter Methoden}

Nach dem Verschaffen eines Überblicks, wird nun auf die Anwendung der
gesammelten Methoden näher eingegangen.

\subsubsection{Relevante Standardwerte}

% TODO: methbox nochmal hier?

Die \methref{relevant_defaults} wurde auf zwei Wegen implementiert. Einmal als
exakte Implementation. Und einmal als Weiterführung im Sinne der Methode.

\begin{code}
  \begin{shellcode}
-d, --date=<value>  [default: this week] A date to specify the week (can be human-readable)
  \end{shellcode}
  \captionof{listing}{Die mit default versehene \codeinline{--date} Flagge.}
  \medskip
\end{code}

Obiger Auszug aus dem Hilfsmenü von \codeinline{hours list} kommuniziert das
die \codeinline{--date} Flagge wenn nicht übergeben den Wert \codeinline{this
week} annimmt. Wird das Kommando \codeinline{hours list} ohne Flaggen aufgerufen
werden die Stunden der aktuellen Woche angezeigt. Natürlich kann auch ein
anderer Zeitraum übergeben werden, die aktuelle Woche wird aber am relevantesten
für die meisten Nutzer sein.

% TODO: relevant-defaults
% dates = today/this week; if only one option, use it; interaktive Vorschläge;

% TODO: autocomplete
% diskussion zu anderen Frameworks

% TODO: interactive_missing_param
% show implementation, warum edit/remove only interaktive?

% TODO: menu
% möglich die ganze App als Menü abzubilden, aber dann wären CLI und Interaktive zu kurz gekommen
% -> outlook

% TODO: flags_over_arguments
% implementiert, show Reihenfolge does not matter, erleichtert auch aliasing,
% kombiniert mit interaktive können nur manche Argumente angegeben werden (+)

% TODO: other methods?


%%% Umfrage
% \chapter{Umfragengestaltung}
% \section{Methodologie}
% \section{Ergebnisartefakte}
% % [Beschreibung der Ergebnisse / Ergebnistypen, welche Sie im Rahmen der Probleml\"osung generieren / erzielen wollen, z.B. Algorithmus, Prototyp einer Software(komponente), ... ]

\chapter{Auswertung}

%%% Finish
\chapter{Zusammenfassung}
% [Aggregierte retrograde Kurzbeschreibung der Arbeit]
\section{Schlussfolgerungen}
% [Beschreibung der insgesamt zu konstatierenden Schlussfolgerungen im Zusammenhang mit der Arbeit]
\section{Limitationen}
% [Beschreibung der Ergebnisse einer kritischen Reflektion und Begr\"undung dessen, was die Arbeit nicht zu leisten vermag]
\section{Ausblick}
% [Beschreibung und Begr\"undung potenzieller zuk\"unftiger Folgeaktivit\"aten im Zusammenhang mit Ihrer Arbeit (z.B. weitere Anforderungen, Theoriebildung, ... ]

\subsection{Erarbeitung weiter Methoden}

Mit mehr Zeit hätten sich weitere Methoden formulieren lassen.
% TODO: hier andere Methoden to look into

\subsection{Strukturierung und Zugänglichkeit der Methoden}

Die Methoden könnten in stärker strukturierter Form und außerhalb des Kontextes
dieser Arbeit für sich stehend formuliert werden. Zusammen mit einer englischen
Übersetzung wären sie dadurch dann leichter referenzier- und implementierbar.

\subsection{Verbesserung der Implementation}

Die konkrete Implementierung hat noch einige Schwächen. So gibt es Dopplungen in
den Hilfsmenüs (etwa \codeinline{timecard} in Listing \ref{code:oraclett-help}
oder \codeinline{hours add/log} in Listing \ref{code:hours-help}), inakkurate
Hilfstexte in der Autovervollständigung oder im \codeinline{oraclett --help}
Menü sowie das die Autocompletion erst durch den Nutzer konfiguiert werden
muss. Diese Probleme sind der Nutzung des ocli Frameworks geschuldet. Es gibt
Möglichkeiten diese zu Adressieren, das war aber im Rahmen dieser Arbeit nicht
möglich.
% TODO: reference to autocomplete implementaton

Eine Anbindung an Oracle selbst war im Rahmen dieser Arbeit nicht vorgesehen,
weil der Fokus auf den Methoden lag. Als zukünftige Verbesserung der App wäre
dies aufgrund der Zeitersparnis aber sinnvoll.

\subsection{Evaluation der Methoden}

Es wäre sinnvoll den Effekt der Methoden auf die Nutzbarkeit zu messen. Etwa
durch Implementierung einer zweiten App welche die gleichen Anforderungen
erfüllt, aber mit explizit nicht implementierten Methoden. Um diese beiden Apps
dann gegenüber zu stellen um zu schauen welche Effekte bei welchen Nutzergruppen
auftreten.

%%% possible modules
% \section{Kontext}
% \subsection{Domain}
% \subsection{Technologien}
% \subsection{Methoden und Konzepte}
% \section{...}
% \subsection{...}
% \subsection{...}
% \chapter{Anforderungserhebung und -analyse}
% \section{Nutzer- und Systemanforderungen}
% \subsection{Funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \subsection{Nicht-funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \section{...}
% \chapter{Konzeption \& Entwurf}
% [Beschreibung des Entwurfs auf Basis der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen (i.A. der Art der Arbeit)]
% \section{Prozess}
% \section{Systemarchitektur}
% \section{Softwarearchitektur}
% \section{Schnittstellen}
% \section{Datenmanagement}
% \section{...}
% \chapter{Implementierung}
% [Beschreibung der Implementierung\footnotemark auf Basis des Entwurfs und der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen. Hier ist Raum f\"ur Listings, wie z.B. das nun Folgende: Umfangreicher Quell-Code sollte in den Anhang ausgelagert werden.]
% \chapter{Test}
% [Beschreibung, wie Sie auf Basis des geplanten Testvorgehens was mit welchen Kriterien und Technologien getestet haben]
% \chapter{Darstellung und Bewertung der Ergebnisse}
% [Beschreibung der Ergebnisse aus allen voran gegangenen Kapiteln sowie der zuvor generierten Ergebnisartefakte mit Bewertung, wie diese einzuordnen sind]

% \bibliographystyle{apalike}
% \bibliographystyle{ksfh_nat} % ein anderer Stil
% \bibliography{science}
\printbibliography[
heading=bibintoc,
title={Quellenverzeichnis}
]

\newpage
\chapter{Glossar}
\begin{appendix}
\pagenumbering{Roman}
\chapter{Appendix}

\section{Quell-Code}

\section{Tipps zum Schreiben Ihrer Abschlussarbeit}

\begin{itemize}
\item Achten Sie auf eine neutrale, fachliche Sprache. Keine \glqq{}Ich\grqq{}-Form.
\item Zitieren Sie zitierf\"ahige und -w\"urdige Quellen (z.B. wissenschaftliche Artikel und Fachb\"ucher; nach M\"oglichkeit keine Blogs und keinesfalls Wikipedia.
\item Zitieren Sie korrekt und homogen.
\item Verwenden Sie keine Fu{\ss}noten f\"ur die Literaturangaben.
\item Recherchieren Sie ausf\"uhrlich den Stand der Wissenschaft und Technik.
\item Achten Sie auf die Qualit\"at der Ausarbeitung (z.B. auf Rechtschreibung).
\item Informieren Sie sich ggf. vorab dar\"uber, wie man wissenschaftlich arbeitet bzw. schreibt:
\begin{itemize}
\item Mittels Fachliteratur\footnote{Z.B. \autocite{balzert2011}, \autocite{franck2013}}, oder
\item Beim Lernzentrum\footnote{Weitere Informationen zum Schreibcoaching finden sich hier: \url{https://www.htw-berlin.de/studium/lernzentrum/studierende/schreibcoaching/}; letzter Zugriff: 13 VI 19.}.
\end{itemize}
\end{itemize}

\newpage
\thispagestyle{empty}
\noindent

\section*{Eidesstattliche Versicherung}
Hiermit versichere ich an Eides statt durch meine Unterschrift, dass ich die vorstehende Arbeit selbstst\"andig und ohne fremde Hilfe angefertigt und alle Stellen, die ich w\"ortlich oder ann\"ahernd w\"ortlich aus Ver\"offentlichungen entnommen habe, als solche kenntlich gemacht habe, mich auch keiner anderen als der angegebenen Literatur oder sonstiger Hilfsmittel bedient habe. Die Arbeit hat in dieser oder \"ahnlicher Form noch keiner anderen Pr\"ufungsbeh\"orde vorgelegen.\\
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
-------------------------------------------------------\linebreak[4]
Datum, Ort, Unterschrift

\end{appendix}
\end{document}
