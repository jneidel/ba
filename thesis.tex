\documentclass[oneside,bibliography=totocnumbered,BCOR=5mm]{scrbook}

\usepackage[ngerman]{babel}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
% \setmainfont{Times}
\setmonofont{FuraCode Nerd Font Mono} % from fc-list

\usepackage[
backend=biber,
style=numeric,
citestyle=authoryear,
autocite=footnote
]{biblatex}
\addbibresource{bibliography.bib}
\addbibresource{extra.bib}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage[newfloat]{minted}
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}

\newenvironment{code}{\captionsetup{type=listing, skip=0pt}}{}
\SetupFloatingEnvironment{listing}{name=Code}

\newminted{shell}{
  linenos,
  numbersep=6pt,
  frame=lines,
  framesep=2mm,
  fontsize=\footnotesize
}
\newmintinline[codeinline]{shell}{
  fontsize=\small
}

%%%%%% other packages %%%%%%

\usepackage{marvosym}
\usepackage{csquotes}
\usepackage{hyperref}

% \usepackage[hyphens]{url}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

% \usepackage{abstract} % Allows abstract customization
% \renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
% \renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

% \usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
% \titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
% \titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
% \fancyhead[C]{Ethics in Progress (EiP) $\bullet$ 2019 } % Custom header text
% \fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\begin{document}

% Titelseite
% \pagestyle{empty}       % keine Seitennummer
\begin{titlepage}
\begin{center}
\includegraphics{htw-logo.jpg}
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\textit{\large Entwicklung und Evaluation von Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen-Interfaces}
\linebreak[4]
\linebreak[4]
\linebreak[4]
Abschlussarbeit
\linebreak[4]
\linebreak[4]
zur Erlangung des akademischen Grades:
\linebreak[4]
\linebreak[4]
\textbf{Bachelor of Science (B.Sc.)}
\linebreak[4]
\linebreak[4]
an der
\linebreak[4]
\linebreak[4]
Hochschule f\"ur Technik und Wirtschaft (HTW) Berlin
\linebreak[4]
Fachbereich 4: Informatik, Kommunikation und Wirtschaft
\linebreak[4]
Studiengang \textit{Angewandte Informatik}
\linebreak[4]
\linebreak[4]
\linebreak[4]
1. Gutachter: Titel akademischer Grad Vorname Nachname\linebreak[4]
2. Gutachter: B.Sc. Moritz Wachter\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Eingereicht von Jonathan Neidel [573619]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Datum

\end{center}
\end{titlepage}
\newpage

\thispagestyle{empty}
\vspace*{2.2cm}
\noindent
{\Huge Danksagung}\\
\vspace*{1.6cm} \\

% Kopfzeilen (automatisch erzeugt)
%\pagestyle{headings}
[Text der Danksagung]

% Seite mit Abstracts
\newpage
\thispagestyle{empty}
\section*{Zusammenfassung}
[Text der Zusammenfassung]

\section*{Abstract}
[Summary of the thesis]


\clearpage
%Seite 1
\pagenumbering{roman}
%\setcounter{page}{1}

\tableofcontents
.
\newpage

\pagenumbering{arabic}
% \setcounter{page}{1}   % setzt Seitenzaehlung auf 1

% \fbox{\parbox{\linewidth}{
% }}

% \\
% \linebreak[4]

% \footnote{Erg\"anzende Informationen k\"onnen Sie auch in eine Fu"snote auslagern. Hier wird die Fu"snote dazu genutzt, um Ihnen bei Interesse am Thema Zitation vertiefende Quellen (z.B. \autocite{balzert2011} oder \autocite{franck2013}) anzubieten.}

% \begin{table}
% \caption{\"Ubersicht: Untersuchte Steinl\"ause}
% \centering
% \begin{tabular}{llr}
% \toprule
% \multicolumn{2}{c}{Untersuchte Objekte mit Lokation des Habitats} \\
% \cmidrule(r){1-2}
% ID (nickname) & Ort & Gr\"o"se/L\"ange (in mm) \\
% \midrule
% 1 (Rosalinde) & Berlin, Mauerpark & $1.4$ \\
% 2 (Devil in disguise) & Brandenburg, BER-Airport & $2.8$ \\
% 3 (Hannes) & Berlin, Olympia-Stadion & $2.1$ \\
% 4 (Her Majesty) & Berlin, Humboldt-Forum & $2.0$ \\
% \bottomrule
% \end{tabular}
% \end{table}

\chapter{Einleitung}
\section{Hintergrund der Arbeit}
% [Beschreibung des groben Kontextes der Arbeit; im Detail sollten Sie dies im Grundlagenteil darstellen]

Die Kommandozeile und darauf basierende Applikationen bergen das Potential für Produktivitätssteigerungen im Vergleich zu GUI Applikationen, vorrausgesetzt der Nutzer weiß mit dieser umzugehen. % TODO: Citation needed


\section{Problem- und Zielstellung (Scope)}
% [Beschreibung der Problemstellung sowie der sich daraus ergebenden Teilprobleme,-ziele und Forschungsfrage(n), welche Sie mit Ihrer Arbeit addressieren]

Die Kommandozeile und seine Applikationen sind für Personen welche mit dieser Umgebung nicht vertraut sind schwer benutzbar. % TODO: Citation needed
Einflussfaktoren dafür sind:

\begin{enumerate}
  \item Fehlendes Wissen über das Ökosystem (wie werden Applikationen gestartet, wie findet man Hilfe, Verständnis grundsätzlicher Werkzeuge fehlt)
  \item Applikationen sind nicht für Neulinge konzipiert
\end{enumerate}

Problemstellung dieser Arbeit soll das zweite der gelisteten Probleme sein: Das Zusammentragen und Evaluieren der Faktoren welche Kommandozeilen Applikation für Neulinge zugänglich machen. Oder konkreter als Forschungsfrage definiert:

\bigbreak

\fbox{\parbox{\linewidth}{
Welche Faktoren sind für die Konstruktion einer Command-Line basierten App zu
beachten um diese für Personen, welche nicht mit dem Terminal vertraut sind,
zugänglich zu machen?
}}

\section{Aufbau der Arbeit}
% [Beschreibung des Aufbaus der Arbeit]

Die Arbeit gliedert sich in folgende drei Hauptteile:

\begin{enumerate}
  \item \textbf{Erarbeitung von Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen Interfaces}:
    \smallbreak
    In Literaturrecherche werden Methoden zusammengetragen und formuliert.
    Diese sind - wie im Sinne des Wortes Methode (``Weg zu etwas hin'' laut \cite{duden_methode}) - deskriptiv und beschreiben wie ein gewünschter Effekt zu erzielen sein soll.
    \begin{enumerate}
      \item \textbf{Probleme mit Kommandozeilen Interfaces}:
        \smallbreak
        Es werden zuerst Probleme, welche die Nutzung von Kommandozeilen Interfaces erschweren erläutert.
      \item \textbf{Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen Interfaces}:
        \smallbreak
        Methoden werden formuliert und wie diese zuvor geschilderte Probleme adressieren.
    \end{enumerate}

  \item \textbf{Implementation einer Anwendung auf Basis der erarbeiteten Methoden}:
    \smallbreak
    Gesammelte Methoden werden in der Implementation einer App demonstriert.
    Die App ist überschaubar komplex und adressiert das manuelle Festhalten von Arbeitsstunden.
    \begin{enumerate}
      \item \textbf{Anforderungsanalyse}:
        \smallbreak
        Zuerst werden die von der App zu erfüllenden Anforderungen erörtert.
      \item \textbf{Implementation der App unter Berücksichtigung gesammelter Methoden}:
        \smallbreak
        Es werden die Anforderungen unter Beachtung ermittelter Methoden implementiert.
    \end{enumerate}

  \item \textbf{Evaluation der implementierten Anwendung}:
    \smallbreak
    Die App wird von mit dem Anwendungsfall vertrauten Kommandozeilen Einsteigern getestet.
    Und Anhand einer Umfrage evaluiert.
    \begin{enumerate}
      \item \textbf{Umfragengestaltung}:
        \smallbreak
        Es wird die Umfrage gestaltet.
      \item \textbf{Auswertung}:
        \smallbreak
        Ergebnisse der Umfrage werden ausgewertet.
    \end{enumerate}
\end{enumerate}

\chapter{Grundlagen und Definitionen}
% [Beschreibung des Kontextes der Arbeit mit allen durch die Problemstellung tangierten Bereichen, Methoden, Theorien, Erkenntnissen, Technologien, ... ]

% TODO: CLI, how did we get here, <-> GUI

% TODO: citation needed, multiple tech definitions
\textbf{Kommandozeilen Interface}: (Engl. command-line interface) oft auch als \textbf{CLI} abgekürzt

Die Kommandozeile nimmt eine Anfrage, in Form von einer Zeile Text, entgegen und antwortet darauf.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{mullvad-status.png}
  \caption{Ändern und Überprüfen des VPN Standorts in der Linux Kommandozeile mit dem \codeinline{mullvad} CLI}
  \label{fig:mullvad-status}
\end{figure}

Die Kommandozeile existiert in zwei Ausprägungen: dem Betriebssystem CLI, auch
als Shell bekannt (siehe die Linux Shell in Abbildung \ref{fig:mullvad-status})
oder der Kommandozeile einer Anwendung (siehe die Node.js Kommandozeile in
Abbildung \ref{fig:node-calc}).

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{node-calc.png}
  \caption{Durchführung einer Berechnung in der Node.js Kommandozeile}
  \label{fig:node-calc}
\end{figure}

\cite{Spolsky_2001} beschreibt neben der CLI noch zwei weitere Terminal Interfaces welche sich aus diesem entstanden sind:
\\
\textbf{Interaktive CLI}: Ein ``question and answer model'' \parencite[42]{Spolsky_2001} der Kommandozeile, wo der Nutzer mittels Fragen, auf die eine Antwort erwartet wird, entlastet wird. Mehr dazu in Kapitel \ref{chap:interactive}.
\\
\textbf{Menu-driven CLI}: auch als Ncurses CLI bekannt. Das Menü-basierte CLI ähnelt dem GUI indem

% Vergleich zu GUI
% function-orient vs object-oriented vgl. nielson1993

\textbf{Flagge}: Zusammen mit Argumenten sind Flaggen der primäre Weg für eine
CLI App um Werte von Nutzern entgegen zu nehmen \parencite{12factor}. Sie
existieren meist in langer, erkennbar durch die \codeinline{--} am Anfang, oder
kurzer Version, mit nur einem \codeinline{-} und meist dem Anfangsbuchstaben der
Langversion.

\begin{code}
\begin{shellcode}
grep --file FILE
grep -f FILE
\end{shellcode}
\captionof{listing}{Kurze und lange Flaggen am Beispiel equivalenter grep Aufrufe}
\medskip
\end{code}

In dem Beispiel mit grep wird von \codeinline{--file FILE} eine Datei mit
Mustern zum Vergleichen übergeben. Bei mehreren Flaggen ist die Reihenfolge
egal.

\begin{code}
  \begin{shellcode}
  grep --ignore-case
  grep -i
  \end{shellcode}
  \captionof{listing}{Ein Beispiel von Boolean Flaggen}
  \medskip
\end{code}

Die \codeinline{--ignore-case} Flagge von Grep ist eine Boolean Flagge. Meist
wird durch Abwesenheit eine Verneinung ausgedrückt und durch Anwesenheit
\codeinline{true}. Boolean Flaggen übergeben keine Werte sondern ändern das
Verhalten der App. Im Falle von grep's \codeinline{ignore-case} existiert
zusätzliche noch eine \codeinline{--no-ignore-case} Flagge, falls der Nutzer
explizit sein möchte. Kurze Booleanflaggen ermöglichen auch konstrukte
wie dieses: \codeinline{tar -xzf file.tgz}. Es werden die Booleanflaggen
\codeinline{-x}, \codeinline{-z}, wie auch die normale \codeinline{-f FILE}
Flagge kombiniert.

\textbf{Argument}: Argumente erlauben es der CLI Werte von Nutzer anzunehmen.

\begin{code}
  \begin{shellcode}
mv SOURCE DEST
  \end{shellcode}
  \captionof{listing}{Manual Auszug von mv, in seiner simpelsten Form}
  \medskip
\end{code}

Anders als bei Flaggen ist Reihenfolge ausschlaggebend. Beim obigen
\codeinline{mv} Programmaufruf ist das erste Argument die Ausgangsdatei und das
zweite die Zieldatei. Die eigentlichen Dateien unterscheidet nichts, einzig die
Reihenfolge beschreibt die Absicht.


% TODO: Pipe, Interaktive, Menu -> alternative Wege zur Übergabe von Werten

%%% Methoden
\chapter{Methoden zur Absenkung der Nutzungsschwelle}
% TODO: intro here

\section{Methodologie}
% [Beschreibung des geplanten Vorgehens(-modells) zur Lösung der Problemstellung; umfasst u.a.:

Die Artefakte dieses Kapitels sind die folgenden:
\begin{enumerate}
  \item Eine Auflistung von Problemen welche den Umgang mit Kommandozeilen Interfaces erschweren
  \item Eine Auflistung von Methoden, welche diese Probleme adressieren
\end{enumerate}

In Literaturrecherche sollen Probleme erschlossen werden, als auch die dafür -
möglicherweise vielfach - vorliegenden Lösungsansätze. Welche dann, unter Bezug
auf das Problem, als Methoden formuliert dokumentiert werden sollen.
\\
Die Formulierung als Methode soll dabei den Lösungsansatz so beschreiben das
dieser anwendbar ist. Dies ist u.a. erforderlich da die Methoden im nächsten
Schritt angewandt werden sollen.

\section{Probleme mit Kommandozeilen Interfaces}

Es folgen, in nicht priorisierter Reihenfolge, Probleme welche die
Nutzungsschwelle von Kommandozeilen Interfaces erhöhen, d.h. diese weniger
zugänglich.
\\
Diese bestmöglich zu adressieren sollte zu einer Absenkung der Nutzungsschwelle
und damit besser zugänglichen Applikationen führen.

\subsection{Erinnern von Kommandos}

Das Problem des Erinnern von Kommandos (engl. Command recall) beschreibt das
Nutzer sich bei Verwendung eines Programmes an dessen Namen, Kommandos und
Parameter erinnern müssen \parencite{Raskin_2008}.

\fbox{\parbox{\linewidth}{
  \label{prob:command-recall}
  \textbf{Problem~\ref{prob:command-recall}}: Es muss sich an Programmname, Kommandos und Parameter erinnert werden.
}}

Um dieses allgemeine Problem zu adressieren wird es sind kleinere Teilprobleme
aufgespalten.

\medskip

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{empty-prompt.png}
  \caption{Die Shell bietet nichts an, ohne ein Programm zu kennen passiert nichts.}
\end{figure}

\cite{Gentner_1996} beschreibt auch den Fakt das es keinen einfachen Weg zum
Auffinden von Programmen gibt.
\\
Der Nutzer muss also den Namen des Programmes kennen um dieses zu nutzen.

\smallskip

Unter der Annahme den Names des Programmes zu kennen, geht es nun darum einen
Programmaufruf mit Kommandos und Parametern zusammen zu bauen.
Hierzu können verschiedene Szenarien betrachtet werden.
Der Nutzer:

\begin{enumerate}
  \item hat Kommandos und Parameter auswendig gelernt
  \item baut den Programmaufruf mit Hilfe der Dokumentation zusammen
  \item fügt den Programmaufruf (mit copy-paste) ein
  \item ruft das das Programm indirekt auf (über ein Script oder Alias)
\end{enumerate}

Diese Szenarien sind aber alle nicht ideal:

\medskip

Das 1. Szenario gilt nur mit dem Programm vertraute Nutzer. Und selbst diese
vergessen mit der Zeit. % TODO: citation needed, vergessen

\medskip

Szenario Nummer 2. ist zeitintensiv für den Nutzer. Auch gilt die Annahme das
Dokumentation existiert und das der Nutzer mit dieser umgehen kann.

\medskip

Für Szenario Nummer 3. muss der Nutzer von irgendwo kopieren, die Quelle ist
hier entweder auch die Dokumentation oder externe Portale wie Foren oder
Stack Overflow. In der Dokumentation musst der Programmaufruf auch erstmal
gefunden werden. Und die externen Portale sind für den Bau des Interfaces nicht
verlässlich.

\medskip

Szenario Nummer 4. gilt nur für erfahrene Nutzer die schon mit der Shell
vertraut sind.

\medskip

Es gibt auch Mischformen, wie das der Nutzer Kommando aber nicht Parameter kennt
und dieses nachschaut, diese sind aber in der Betrachtung zu vernachlässigen, da
die Kritiken an den Reinformen auch für sie gelten.

\subsection{Syntax und Semantik}

``Commands and associated parameters must be typed, maintaining the correct
semantic content and syntactic form.'' \parencite[184]{Westerman_1997}

\cite{Gentner_1996} beschreibt die Kommandozeile auch als sehr starr und wenig
Tolerant gegenüber imperfekter Syntax.

\fbox{\parbox{\linewidth}{
  \label{prob:syntax-semantik}
  \textbf{Problem \ref{prob:syntax-semantik}}: Die richtige Syntax and Semantik muss gewährleistet werden.
}}

\bigskip

Ein Beispiel für fehlerintolerante Syntax am Beispiel von \codeinline{grep}.
Die man page beschreibt die Syntax: \codeinline{grep [OPTION...] PATTERNS [FILE...]}.
Beim schnell-geschehenen Vertauschen von \codeinline{FILE} und \codeinline{PATTERNS}:

\begin{code}
  \begin{shellcode}
grep ./file "[a-z]{3}"
/bin/grep: [a-z]{3}: No such file or directory
  \end{shellcode}
  \captionof{listing}{Fehlerhafte Kommando Syntax bei grep}
  \medskip
\end{code}

Der Bedeutungsgehalt von Kommandos kann an diesem Beispiel dargestellt werden:

\begin{code}
  \begin{shellcode}
git remote add [..]
git add remote
  \end{shellcode}
  \captionof{listing}{Kommando Semantik am Beispiel von git}
  \medskip
\end{code}

Das Kommando \codeinline{git remote} ist zum verwalten von `tracked repositories'.
\codeinline{git add} markiert eine Datei für den nächsten `commit'.
Je nach Kontext haben \codeinline{add} und \codeinline{remote} eine andere Bedeutung.
\codeinline{git remote add} fügt eine neue `repository' hinzu, \codeinline{git
add remote} markiert aber eine Datei mit dem Namen \codeinline{./remote} für den
nächsten `commit'.

\section{Adressierung der Probleme durch Weiterentwicklungen}

Ziel dieser Arbeit ist es Methoden zur Adressierung dieser fundamentalen
Probleme innerhalb der Form der Kommandozeile zu beschreiben.

Die meisten Abhandlungen über das Angehen dieser Probleme versuchen aber aus
dieser Form von Interface auszubrechen.

Historisch wurde die grafische Benutzeroberfläche als Lösung für die Probleme der
CLI gesehen (\cite{Norman_2007}). % TODO: other cite

Laut \cite{nielson1993} vollzog sich damit ein Wechsel von `function-oriented',
der in der Kommandozeile typischerweise vorhandenen Verb-Nomen Struktur (z.B.
\codeinline{rm file}), hin zu der Objekt-orientierten GUI, dem Auswählen des
Objektes und dann der Aktion welche darauf angewandt werden soll (z.B. Datei in
den Papierkorb ziehen.)

% TODO: modern answer engine, shared DNA with CLI
 % \cite{Norman_2007}

% TODO: human language, über Syntax hinaus, menschliche Sprache verstehen
% Raskin_2008

% Conclusions von seneviratne2008new lesen

% TODO: visual cli a la Glaser et al. (1995), see seneviratne2008new

\section{Gesammelte Methoden}
% Methoden beziehen sich direkt auf ein Problem welches adressiert werden soll.

\newcommand{\methbox}[2]{
  \fbox{\parbox{\linewidth}{
    \label{meth:#1}
    \textbf{Methode~\ref{meth:#1}}: #2
  }}
}
\newcommand{\methref}[1]{
  Methode~\ref{meth:#1}
}

Anders als erhofft gestaltete sich die Recherche nach Methoden zur Absenkung
der Nutzungsschwelle als schwierig da, wie bereits angesprochen, das GUI oder
eine andere Form von Nutzerinterface oft als Lösung für die Probleme von
Kommandozeilen angeführt wird.

% Konkrete Handlungsanweisungen, wie bei \cite{12factor} und
% \cite{nagarajan2018}, halten sich nicht exakt

% TODO: ...

%  philosophie/prinzipien

\subsection{Interaktive CLI}
% TODO: move this section into definitions

Als Interaktive CLI ist eine solche bekannt die dem Nutzer nach und nach Fragen
stellt, ähnlich einem Formular. Wie bei einem Formular kann neben Freitext kann
dem Nutzer mit Radiobuttons (auswählen von einer Option aus einer Liste) oder
Checkboxen (auswählen mehrerer Optionen aus einer Liste) zum auswählen. % TODO: fix

% TODO: screenshot mit Q&A format

% TODO: extend, reference sources
% bland2007design, Gentner_1996

\subsubsection{Interaktive Frage bei fehlendem Parameter}

% TODO: vgl. Command recall
Man stelle sich folgendes Szenario vor. Eine CLI hat ein Kommando welches einen Parameter erfordert.
Normalerweise erfolgt beim Vergessen der Übergabe dieses Parameters eine Fehlermeldung welche diesen Fakt schildert.

\begin{code}
  \begin{shellcode}
mullvad relay set location

error: The following required arguments were not provided:
    <country>

USAGE:
    mullvad relay set location <country> [ARGS]

For more information try --help
  \end{shellcode}
  \captionof{listing}{Fehlermeldung bei fehlendem Parameter in mullvad (VPN) CLI}
  \medskip
\end{code}

Die CLI weiß aber schon was der Nutzer tun möchte und könnte anstatt der
Fehlermeldung einen Prompt geben welcher den Nutzer fragt eine Parameter zu
übergeben oder, je nach Kontext, einen vorzuschlagen. Dem Nutzer wird erspart
sich mit der richtigen Syntax und den Vokabeln auseinander zu setzen.

\methbox{interactive_missing_param}{Bei fehlendem Parameter soll interaktiv nachgefragt werden.}

\begin{code}
  \begin{shellcode}
mullvad relay set location
Enter location country code:
  \end{shellcode}
  \captionof{listing}{Prompt welcher direkt nach fehlendem Parameter fragt}
  \medskip
\end{code}

Fairerweise ist zu bemerken das die mullvad CLI dies auch an anderer Stelle so handhabt, so fragt die CLI bei \codeinline{mullvad account login} nach der fehlenden Accountnummer.

Negativ an dieser Methode wäre das der Nutzer nicht im gleichen Maße auf die
Möglichkeit einer komplexeren Verwendung des Kommandos hingewiesen wird (so
nimmt das mullvad Kommando aus obigem Beispiel nicht nur Landes- sondern auch
Stadt- und Hostkennungen). Außerdem wird der Programmaufruf ohne den Parameter
in der Shell History gespeichert, was bedeutet bei das bei zurückgehen zu dem
Aufruf der fehlende Parameter immer noch fehlt und ergänzt oder erneut über den
Prompt übergeben werden muss. % TODO: shorten

Beide Punkte sind aber für Einsteiger eher zu vernachlässigen.

\subsection{Menü oder TUI}

% TODO: screenshot
Das Menü oder auch `Text-based user interfaces' ähneln dem GUI dadurch das der
Nutzer seine Optionen visuell präsentiert bekommt und daraus ausgewählen kann.
\\
Da es aber wie die CLI in Terminal lebt werden auch zum darstellen des Menüs
nur Textelemente verwendet. Zur Implementation wird oft die ncurses Bibliothek
verwendet.

\bigskip

Im einem Experiment von \cite{Westerman_1997} hatte das Menü-basierte
Interface, für manche Nutzergruppen, unsignifikant bessere Performance als
ein Kommandozeilen Interface. Auch wurde bei freier Wahl das Menü über alle
Nutzergruppen hinweg doppelt so häufig verwendet.

\methbox{menu}{Biete ein Menü-Interface an.}

% TODO: move and complete

\subsection{Autovervollständigung zum Vorschlagen und Vervollständigen von Kommandos/Flaggen}

Auto-completion in der Kommandozeile beschreibt das Verhalten das bei drücken der
(normalerweise) `TAB' Taste etwas vervollständigt wird.

In der Shell funktioniert dies etwa für Programmnamen und die Pfade von Dateien:
\begin{code}
  \begin{shellcode}
wg # Nutzer drueckt TAB
wget

cat ./note # Nutzer drueckt TAB
cat ./notes.md
  \end{shellcode}
  \captionof{listing}{Autovervollständigung in der Shell}
  \medskip
\end{code}

Bei Programmen kann dies, neben der Vervollständigung von Dateipfaden, auch
Kommandos und Flaggen umfassen.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{mullvad-autocomplete.png}
  \caption{Bei mullvad's CLI werden nach dem drücken von `TAB' mögliche Kommandos aufgelistet}
  \label{fig:autocomplete}
\end{figure}

% TODO: Vorschlagen beschreiben

\methbox{autocomplete}{Dem Nutzer sollte innerhalb der App Autovervollständigung zu verfügung gestellt werden.}

Auto-completion adressierte beide Probleme welche das CLI mit sich bringt, durch
das Vorschlagen und Vervollständigen erleichtert das Erinnern des gesuchten
Kommandos. Und dadurch das nur valide Kommandos vorgeschlagen werden ist das
einhalten von Syntax- und Semantikregeln erleichtert. Auch profitiert der Nutzer
von Kontext-bezogenen Beschreibungen.

In \cite{dutta} geht der Author sogar noch einen Schritt weiter und empfehlen
das automatische Vorschlagen aller Flaggen und Argumente für ein Kommando,
sodass der Nutzer sich nicht mal anschauen muss was für das Kommando benötigt
wird. So wie vom Author beschrieben ist dies aber nicht in der Shell möglich,
sondern müsste meiner Einschätzung nach eine eigene Kommandozeilen Umgebung
gebaut werden, was nicht im Sinne der Zielstellung dieser Arbeit liegt.

\subsection{Relevante Defaults}

Relevante Defaults sind nicht Kommandozeilen spezifisch, können dort aber
wichtiger sein als in grafischen Anwendungen.
\\
Dem Nutzer werden die Möglichkeiten eben nicht zur Auswahl gestellt und dieser
klickt die gewünschte Option an. Sondern ist das Auflisten der Möglichkeiten
i.d.R. ein separater Schritt, losgelöst von dem Schritt der Nutzung der Option
(z.B. werden mit \codeinline{ls -d} zuerst die Ordner aufgelistet, um sich dann
mit \codeinline{cd ORDNER} in einen von diesen hineinzubewegen, siehe auch Abbildung \ref{fig:defaults-demo}.)
\\
Es greift wieder das fundamentale Problem des `Command Recall' (vgl. Problem
\ref{prob:command-recall}). Den Schritt des Auflistens der Möglichkeiten
(ähnlich wie das Auflisten von möglichen Kommandos) ist ein extra Schritt, außer
der Nutzer kann sich an die gewünschte Option erinnern.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{defaults-demo.png}
  \caption{Der erforderte Parameter in dieser Literaturverwaltung ist einer Liste zu entnehmen}
  \label{fig:defaults-demo}
\end{figure}

\bigskip

\methbox{relevant-defaults}{Falls möglich, sollen Argumente relevanten Defaults haben.}

% TODO: elaborate

% TODO: describe 12 Factor methods
% https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46
\subsection{Flaggen anstatt Argumenten}
% 2. Prefer flags to args

Sobald ein Kommando mehr als ein Argument annimmt, biete sich die Gelegenheit
die für Argumente relevante Reihenfolge durcheinander zu bringen (vgl. Command
Recall und Syntax % TODO: fix formating

). \cite{12factor} empfiehlt deshalb bei zwei oder mehr Argumenten Flaggen zu
verwenden. Das ist etwas mehr Aufwand zum Schreiben aber die Reihenfolge als
Fehlerfaktor (vgl. Syntax

) und Flaggen können nun auch mittels Autovervollständigung vorgeschlagen werden
(vgl. \methref{autocomplete}).

\methbox{flags_over_arguments}{Wenn zwei oder mehr Argumenten erforderlich sind nutze stattdessen Flaggen.}

Dies trifft vorallem zu wenn wenn bei dem Kommando schon andere Werte über
Flaggen übergeben werden.

\begin{code}
  \begin{shellcode}
oraclett project add INTPD999DXD --taskDetail "01 - Career development"
oraclett project add --project INTPD999DXD --taskDetail "01 - Career development"
  \end{shellcode}
  \captionof{listing}{Argument ersetzt durch Flaggen: vorher und nachher}
  \medskip
\end{code}

Außen vor sind auch Kommandos welche eine variable Anzahl an Argumenten nehmen,
Beispielsweise \codeinline{rm file1 file2 file3}, weil es sich bei diesen nicht
um verschiedene Typen von Argument handelt \parencite{12factor}.

\subsection{Aliase für Kommandos und Flaggen}
% 3. What version am I on? -> aliases, get the user what they are looking for

\begin{code}
  \begin{shellcode}
app -h
app --help
app help

app -v
app -V
app --version
app version
  \end{shellcode}
  \captionof{listing}{Es ist klar was der Nutzer hier angezeigt bekommen will}
  \medskip
\end{code}

\newcommand\checkmark{\ttfamily{\char"2611}} % or 2713
\newcommand\cross{\ttfamily{\char"2610}}

\begin{table}[h!]
  \begin{center}
    \caption{Auflistung von 15 Programmen darüber welche Varianten funktionieren um Hilfe bzw. Version anzuzeigen}
    \label{tab:help_version}
    \begin{tabular}{l c c c c c c c}
Programm & -h & ---help & help & -v & -V & ---version & version \\
      \hline
git & \checkmark & \checkmark & \checkmark & \checkmark & \cross & \checkmark & \checkmark \\
node & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
mullvad & \checkmark & \checkmark & \cross & \cross & \cross & \cross & \checkmark \\
grep & \cross & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
zathura & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
tsp & \checkmark & \cross & \cross & \cross & \checkmark & \cross & \cross \\
pubs & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
mp3cut & \checkmark & \cross & \cross & \cross & \cross & \cross & \cross \\
systemctl & \checkmark & \checkmark & \cross & \cross & \cross & \checkmark & \cross \\
pacman & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
make & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
synctex & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\
curl & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross \\
ansible & \checkmark & \checkmark & \checkmark & \cross & \cross & \checkmark & \cross \\
nvim & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross \\
      Summe & 14 & 13 & 3 & 7 & 5 & 12 & 3 \\
    \end{tabular}
  \end{center}
\end{table}

%%% Bauen
\chapter{Anforderungsanalyse}
% [Beschreibung der Erhebung, Granularisierung und Priorisierung der zu Grunde liegenden Anforderungen]

Die zu bauende Anwendung wurde konzipiert nicht zu trivial - um genug
Spielraum im Interface Design zuzulassen - aber auch nicht zu komplex - um die
Umsetzbarkeit zu gewährleisten - zu sein.

\section{Konzept}
\subsection{Problem}

Bei Endava werden die Arbeitsstunden über ein Oracle System festgehalten. Dieses
glänzt nicht in Usability, es führt aber kein Weg dran vorbei.

% TODO: screenshot best case

Das System funktioniert so, dass ein mal wöchentlich die Zeiten der vergangen
Woche abgegeben werden müssen. In diesen Timecards wird angegeben an welchen
Wochentagen man wie viele Stunden an welchem Projekt gearbeitet hat. Bei einem
Projekt und 40 Stunden Woche ist das ausfüllen trivial. Aber sobald man seine
Zeit zwischen mehreren Projekten mit schwankender Stundenzahl aufteilt wird
es komplizierter. Außerdem wird teils gefordert sich Notizen zu machen woran
gearbeitet wurde. Zusammengenommen heißt dies: täglich müssen Dinge bei Oracle
eingetragen werden.

% TODO: screenshot realistic case

\subsection{Lösungsansatz}

Die entworfene Lösung ist eine Kommandozeilen App welche das tägliche loggen der
Arbeitszeiten, und Notizen woran gearbeitet wurde, vereinfacht. Und diese Daten
dann zum wöchentlichen Übertragen in Oracle in strukturierter Form ausgibt.
Dadurch wird erreicht nur das erforderliche Minimum der Zeit mit Oracle zu
verbringen, dessen Workflow im übrigen auch am besten funktioniert wenn alles in
einem Rutsch erledigt wird.
\\
Weil es den Rahmen sprengen würde, ohne dem Thema dienlich zu sein, wurde davon
abgesehen die CLI an ggf. bestehende Oracle APIs anzubinden.

\section{Anforderungen}

Die Anforderungen wurden in Form von User Stories festgehalten. Erhoben wurden
diese durch den Author in Analyse der eigenen Nutzungsmuster mit Oracle,
abgeglichen in Rücksprache mit anderen Mitarbeitern.

\begin{enumerate}
  \item \textbf{Verwaltung von Projekten}:
    \begin{enumerate}
      \item Als Nutzer möchte ich einen Projekt Schlüssel hinzufügen.
      \item Als Nutzer möchte ich einem Projekt Schlüssel ein oder mehrere Task Details anfügen.
      \item Als Nutzer möchte ich die Projekt Schlüssel sowie deren Task Details aufgelistet sehen.
      \item Als Nutzer möchte ich Projekt Schlüssen und Task Details anpassen oder löschen.
    \end{enumerate}
  \item \textbf{Arbeitszeit loggen}:
    \begin{enumerate}
      \item Als Nutzer möchte ich meine Arbeitsstunden an einem Tag für eine Project Code-Task Detail Kombination loggen.
      \item Als Nutzer möchte ich die geloggten Arbeitsstunden einer gegebenen Woche einsehen.
      \item Als Nutzer möchte ich geloggte Arbeitsstuden anpassen oder löschen.
    \end{enumerate}
  \item \textbf{Verwaltung von Arbeitsnotizen}:
    \begin{enumerate}
      \item Als Nutzer möchte ich etwas festhalten an dem ich an einem Tag gearbeitet habe.
      \item Als Nutzer möchte ich meine Notizen für einen Tag bearbeiten oder löschen.
    \end{enumerate}
  \item \textbf{Report Generierung}:
    \begin{enumerate}
      \item Als Nutzer möchte ich einen Report für eine gegebene Arbeitswoche generieren, um die Daten in Oracle zu übertragen.
    \end{enumerate}
\end{enumerate}

Diese User Stories sollen einen Eindruck über die Anforderungen der App
und deren Komplexität vermitteln. Das Bauen der App steht aber nicht im
Vordergrund, weshalb u.a. hier die Akzeptanzkriterien der User Stories,
Implementationsdetails wie Datenpersistierung, etc. nicht weiter beschrieben
werden.

\chapter{Implementation}
\section{Fundament}

Das Fundament der App stellen die zugrundelegenden technologischen Aspekte dar,
welche nicht oder nur indirekt die Nutzbarkeit, und damit den Fokus der Arbeit
betreffen.

Node.js wurde als Programmiersprache gewählt, weil der Author damit vertraut
war, eine vielzahl von Liberies zum Bauen von CLI's existieren und der
Paketveröffentlichungsprozess mit npm relativ simpel ist.
Weiterhin wurden noch Typescript, für Typisierung, und Eslint, für gleichmäßigen
Code Style, verwendet.

\section{Libraries}

Ein Überblick über die Libraries welche für das Bauen des Interfaces und die
Umsetzung der Methoden relevant waren.

\subsection{oclif}

``oclif is an open source framework for building a command line interface
(CLI) in Node.js. Create CLIs with a few flags or advanced CLIs that have
subcommands.'' \parencite{oclif}

oclif biete ein System um ohne viel Boilerplate Kommandos zu bauen, dessen
Flaggen und Argumente zu beschreiben und dann eigene Businesslogik auszuführen
(siehe Abbildung \ref{fig:oclif-list}.) Während oclif Kommando- und
Flaggenparsing, das generieren der Hilfsseite uvm. übernimmt.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{oclif-list.png}
  \caption{Beschreiben eines Kommandos in oclif am Beispiel des implementierten \codeinline{project list} Kommandos}
  \label{fig:oclif-list}
\end{figure}

Die Hierarchie von Kommandos wird über eine Strukurierung der Dateien erreicht (siehe nachstehendes Listing) und der Feinschliff wird noch per Konfiguration in der \codeinline{package.json} erreicht.

\begin{code}
  \begin{shellcode}
 src/commands
 ├── hours
 │   └── list.ts
 └── project
     ├── add.ts
     ├── edit.ts
     ├── list.ts
     └── remove.ts
  \end{shellcode}
  \captionof{listing}{Kommandohierarchie über Dateistruktur: Kommandos und deren Subkommandos}
  \medskip
\end{code}

% TODO: node noch andere libs, oclif warum gewählt? Verweis auf autocomplete

\subsection{Inquirer.js}

Inquirer stellt eine Ansammlung an interaktiven % TODO: reference to earlier chapter
Fragetypen zusammen.
% TODO: ...

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{inquirer-example.png}
  \caption{Eine mit Inquirer.js implementierter Frage und Antwort Flow zum herausfinden was der Nutzer bearbeiten möchte}
  \label{fig:inquirer-example}
\end{figure}

\section{Anwendung gesammelter Methoden}

% TODO: relevant-defaults
% TODO: autocomplete
% TODO: interactive_missing_param
% TODO: menu
% TODO: flags_over_arguments

%%% Umfrage
\chapter{Umfragengestaltung}
\section{Methodologie}
\section{Ergebnisartefakte}
% [Beschreibung der Ergebnisse / Ergebnistypen, welche Sie im Rahmen der Probleml\"osung generieren / erzielen wollen, z.B. Algorithmus, Prototyp einer Software(komponente), ... ]

\chapter{Auswertung}

%%% Finish
\chapter{Zusammenfassung}
% [Aggregierte retrograde Kurzbeschreibung der Arbeit]
\section{Schlussfolgerungen}
% [Beschreibung der insgesamt zu konstatierenden Schlussfolgerungen im Zusammenhang mit der Arbeit]
\section{Limitationen}
% [Beschreibung der Ergebnisse einer kritischen Reflektion und Begr\"undung dessen, was die Arbeit nicht zu leisten vermag]
\section{Ausblick}
% [Beschreibung und Begr\"undung potenzieller zuk\"unftiger Folgeaktivit\"aten im Zusammenhang mit Ihrer Arbeit (z.B. weitere Anforderungen, Theoriebildung, ... ]

%%% possible modules
% \section{Kontext}
% \subsection{Domain}
% \subsection{Technologien}
% \subsection{Methoden und Konzepte}
% \section{...}
% \subsection{...}
% \subsection{...}
% \chapter{Anforderungserhebung und -analyse}
% \section{Nutzer- und Systemanforderungen}
% \subsection{Funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \subsection{Nicht-funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \section{...}
% \chapter{Konzeption \& Entwurf}
% [Beschreibung des Entwurfs auf Basis der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen (i.A. der Art der Arbeit)]
% \section{Prozess}
% \section{Systemarchitektur}
% \section{Softwarearchitektur}
% \section{Schnittstellen}
% \section{Datenmanagement}
% \section{...}
% \chapter{Implementierung}
% [Beschreibung der Implementierung\footnotemark auf Basis des Entwurfs und der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen. Hier ist Raum f\"ur Listings, wie z.B. das nun Folgende: Umfangreicher Quell-Code sollte in den Anhang ausgelagert werden.]
% \chapter{Test}
% [Beschreibung, wie Sie auf Basis des geplanten Testvorgehens was mit welchen Kriterien und Technologien getestet haben]
% \chapter{Darstellung und Bewertung der Ergebnisse}
% [Beschreibung der Ergebnisse aus allen voran gegangenen Kapiteln sowie der zuvor generierten Ergebnisartefakte mit Bewertung, wie diese einzuordnen sind]

% \bibliographystyle{apalike}
% \bibliographystyle{ksfh_nat} % ein anderer Stil
% \bibliography{science}
\printbibliography[
heading=bibintoc,
title={Quellenverzeichnis}
]

\newpage
\chapter{Glossar}
\begin{appendix}
\pagenumbering{Roman}
\chapter{Appendix}

\section{Quell-Code}

\section{Tipps zum Schreiben Ihrer Abschlussarbeit}

\begin{itemize}
\item Achten Sie auf eine neutrale, fachliche Sprache. Keine \glqq{}Ich\grqq{}-Form.
\item Zitieren Sie zitierf\"ahige und -w\"urdige Quellen (z.B. wissenschaftliche Artikel und Fachb\"ucher; nach M\"oglichkeit keine Blogs und keinesfalls Wikipedia.
\item Zitieren Sie korrekt und homogen.
\item Verwenden Sie keine Fu{\ss}noten f\"ur die Literaturangaben.
\item Recherchieren Sie ausf\"uhrlich den Stand der Wissenschaft und Technik.
\item Achten Sie auf die Qualit\"at der Ausarbeitung (z.B. auf Rechtschreibung).
\item Informieren Sie sich ggf. vorab dar\"uber, wie man wissenschaftlich arbeitet bzw. schreibt:
\begin{itemize}
\item Mittels Fachliteratur\footnote{Z.B. \autocite{balzert2011}, \autocite{franck2013}}, oder
\item Beim Lernzentrum\footnote{Weitere Informationen zum Schreibcoaching finden sich hier: \url{https://www.htw-berlin.de/studium/lernzentrum/studierende/schreibcoaching/}; letzter Zugriff: 13 VI 19.}.
\end{itemize}
\end{itemize}

\newpage
\thispagestyle{empty}
\noindent

\section*{Eidesstattliche Versicherung}
Hiermit versichere ich an Eides statt durch meine Unterschrift, dass ich die vorstehende Arbeit selbstst\"andig und ohne fremde Hilfe angefertigt und alle Stellen, die ich w\"ortlich oder ann\"ahernd w\"ortlich aus Ver\"offentlichungen entnommen habe, als solche kenntlich gemacht habe, mich auch keiner anderen als der angegebenen Literatur oder sonstiger Hilfsmittel bedient habe. Die Arbeit hat in dieser oder \"ahnlicher Form noch keiner anderen Pr\"ufungsbeh\"orde vorgelegen.\\
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
-------------------------------------------------------\linebreak[4]
Datum, Ort, Unterschrift

\end{appendix}
\end{document}
