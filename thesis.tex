\documentclass[oneside,bibliography=totocnumbered,BCOR=5mm]{scrbook}

\usepackage[ngerman]{babel}
\usepackage{fontspec}

% look up system fonts via fc-list
% \setmainfont
\setsansfont{SFNS Display}
\setmonofont{FuraCode Nerd Font Mono}

\usepackage[
backend=biber,
bibstyle=authoryear,
citestyle=authoryear,
autocite=footnote
]{biblatex}
\addbibresource{bibliography.bib}
\addbibresource{extra.bib}

\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{float}

\usepackage[newfloat]{minted}
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}

\newenvironment{code}{\captionsetup{type=listing, skip=0pt}}{}
\SetupFloatingEnvironment{listing}{name=Listing}

\newminted{shell}{
  linenos,
  numbersep=6pt,
  frame=lines,
  framesep=2mm,
  fontsize=\footnotesize
}
\newminted{javascript}{
  linenos,
  numbersep=6pt,
  frame=lines,
  framesep=2mm,
  fontsize=\footnotesize
}
\newmintinline[codeinline]{shell}{
  fontsize=\small
}

%%%%%% other packages %%%%%%

\usepackage{marvosym}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{nameref}

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

% \usepackage{abstract} % Allows abstract customization
% \renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
% \renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

% \usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
% \titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
% \titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
% \fancyhead[C]{Ethics in Progress (EiP) $\bullet$ 2019 } % Custom header text
% \fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\begin{document}

% Titelseite
% \pagestyle{empty} % keine Seitennummer
\begin{titlepage}
\begin{center}
\includegraphics{htw-logo.jpg}
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\textit{\large Entwicklung und Evaluation von Methoden zur Absenkung der Nutzungsschwelle von Kommandozeilen-Interfaces}
\linebreak[4]
\linebreak[4]
\linebreak[4]
Abschlussarbeit
\linebreak[4]
\linebreak[4]
zur Erlangung des akademischen Grades:
\linebreak[4]
\linebreak[4]
\textbf{Bachelor of Science (B.Sc.)}
\linebreak[4]
\linebreak[4]
an der
\linebreak[4]
\linebreak[4]
Hochschule f\"ur Technik und Wirtschaft (HTW) Berlin
\linebreak[4]
Fachbereich 4: Informatik, Kommunikation und Wirtschaft
\linebreak[4]
Studiengang \textit{Angewandte Informatik}
\linebreak[4]
\linebreak[4]
\linebreak[4]
1. Gutachter: Prof. Dr.-Ing. Johann Habakuk Israel\linebreak[4]
2. Gutachter: B.Sc. Moritz Wachter\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Eingereicht von Jonathan Neidel [573619]
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
Datum

\end{center}
\end{titlepage}
\newpage

\thispagestyle{empty}
\vspace*{2.2cm}
\noindent
{\Huge Danksagung}\\
\vspace*{1.6cm} \\

% Kopfzeilen (automatisch erzeugt)
%\pagestyle{headings}

[Text der Danksagung]
% - Endava für die Möglichkeit die Arbeit im Betrieb zu schreiben.
% - Moritz für das Engagement
% - Herr Israel der mir bei Fragen zur Seite stand.
% - Francis und Mama für moralischen Support
% - Sven Proofreading

% Seite mit Abstracts
\newpage
\thispagestyle{empty}
\section*{Zusammenfassung}
[Text der Zusammenfassung]

\section*{Abstract}
[Summary of the thesis]


\clearpage
%Seite 1
\pagenumbering{roman}
%\setcounter{page}{1}

\tableofcontents
.
\newpage

\pagenumbering{arabic}
% \setcounter{page}{1} % setzt Seitenzaehlung auf 1

% \footnote{Erg\"anzende Informationen k\"onnen Sie auch in eine Fu"snote auslagern. Hier wird die Fu"snote dazu genutzt, um Ihnen bei Interesse am Thema Zitation vertiefende Quellen (z.B. \autocite{balzert2011} oder \autocite{franck2013}) anzubieten.}

\chapter{Einleitung}
\label{sec:einleitung}

\section{Hintergrund der Arbeit}
[Beschreibung des groben Kontextes der Arbeit; im Detail sollten Sie dies im Grundlagenteil darstellen]

% TODO: rewrite everything
% Die Kommandozeile und darauf basierende Applikationen bergen das Potential für Produktivitätssteigerungen im Vergleich zu GUI Applikationen, vorausgesetzt der Nutzer weiß mit dieser umzugehen. % TODO: Citation needed

\section{Problem- und Zielstellung (Scope)}
[Beschreibung der Problemstellung sowie der sich daraus ergebenden Teilprobleme,-ziele und Forschungsfrage(n), welche Sie mit Ihrer Arbeit addressieren]

% TODO: rewrite everything, Forschungsfrage was adjusted

% Die Kommandozeile und seine Applikationen sind für Personen welche mit dieser Umgebung nicht vertraut sind schwer benutzbar. % TODO: Citation needed
% Einflussfaktoren dafür sind:

% \begin{enumerate}
%   \item Fehlendes Wissen über das Ökosystem (wie werden Applikationen gestartet, wie findet man Hilfe, Verständnis grundsätzlicher Werkzeuge fehlt)
%   \item Applikationen sind nicht für Neulinge konzipiert
% \end{enumerate}

% Problemstellung dieser Arbeit soll das zweite der gelisteten Probleme sein: Das Zusammentragen und Evaluieren der Faktoren welche Kommandozeilen Applikation für Neulinge zugänglich machen. Oder konkreter als Forschungsfrage definiert:

\fbox{\parbox{\linewidth}{
Welche Methoden existieren um die Usability einer CLI App zu erhöhen?
}}

\section{Aufbau der Arbeit}

\begin{enumerate}
  \item \textbf{\nameref{sec:einleitung}}
    \smallbreak
    Definieren der Ziele und Struktur.
  \item \textbf{\nameref{sec:grundlagen}}
    \smallbreak
    Beschreiben grundlegenden Wissens.
  \item \textbf{\nameref{sec:cli-problems}}
    \smallbreak
    Zusammenfassen von Problemen die das Nutzen von Kommandozeilen Interfaces erschweren.
  \item \textbf{\nameref{sec:methods}}
    \smallbreak
    Formulieren von Methoden die zuvor geschilderte Probleme adressieren.
  \item \textbf{\nameref{sec:beispiel-anwendung}}
    \smallbreak
    Definieren und bauen einer beispielhaften App zum Darstellen der Methoden.
  \item \textbf{\nameref{sec:implementation}}
    \smallbreak
    Beschreiben von Details und Schwierigkeiten zur Implementierung der Methoden.
  \item \textbf{\nameref{sec:evaluation}}
    \smallbreak
    Bewerten der Anwendung mittels vergleichender Studie.
  \item \textbf{\nameref{sec:zusammenfassung}}
    \smallbreak
    Ziehen einer Schlußfolgerung.
\end{enumerate}

\chapter{Grundlagen}
\label{sec:grundlagen}

\section{Historischer Kontext}
\label{sec:historic-context}

Die Kommandozeile ist ein Produkt der Evolution von Computern. Die ersten Formen
der Interaktion in Echtzeit kamen zusammen mit dem `teletypewriter' (TTY),
einem Schreibmaschinen-ähnlichem Gerät. Erstmals konnten Menschen ihre Befehle
eingeben und die direkt die Resultate sehen. Das Papier und die mechanischen
TTY's wurden schließlich durch Text-darstellende Displays und elektronische
Tastaturen ersetzt. Diese Interaktionsform mit Tastatur und Textausgabe ist als
\textbf{Kommandozeilen Interface (CLI)} bekannt geworden \parencite[35f]{nagarajan2018}.
Und funktioniert wie folgt:

\begin{enumerate}
  \item Das System fordert den Nutzer auf einen Programmaufruf zu schreiben. (`Read')
  \item Das System führt den Befehl aus und zeigt das Resultat. (`Eval' und `Print')
  \item Diese Sequenz wiederholt sich nun unendlich. (`Loop')
\end{enumerate}

Ein System was dieses Vorgehen implementiert wird auch als REPL (`Read-eval-print
loop`) Umgebung bezeichnet.

\smallskip

Um die Limitation der Kommandozeile\footnote{Im Kapitel \ref{sec:cli-problems}
wird noch tiefer auf die Probleme eingegangen.} zu adressieren wurde
unter anderem das grafische User Interface (\textbf{GUI}) entwickelt
\parencite{nielson1993}. Welches von dem Text-basierten CLI zu dem
heute allgegenwärtigen Fenster, `Icons', Menüs und die Maus mit sich
brachte\footnote{Mehr zu den Weiterentwicklung des CLI in Kapitel
\ref{sec:weiterentwicklungen}.}

% TODO: move into problem after menu and all explainations
% \section{Nutzen der Kommandozeile}

% Wenn die Kommandozeile als historisches Artefakt gilt warum sollte sie heute
% noch verwendet werden?
%
% Das CLI bietet Experten viel Flexibilität konstruieren eines (komplexen)
% Operation \parencite{Norman_1983}. Ein Beispiel für diese Flexibilität wäre
% folgendes. Es sollen alle PDF Dateien aus dem Jahr 2021 gelöscht werden, diese
% haben etwa Namen wie: \codeinline{20210819-Rechnung.pdf}. In der Kommandozeile
% kann dies mit \codeinline{rm 2021*.pdf} erreicht werden. Im grafischen Interface
% müssten die Dateien markiert und gelöscht werden. Mit einer steigender Anzahl
% von Dateien steigt auch der Aufwand und die Chance einen Fehler zu machen.
% In der Shell funktioniert \codeinline{rm} auch problemlos bei einer Million
% Dateien.
% \\
% Ein weiter Vorteil für Experten liegt in dem Erstellen von Skripten. Mit Hilfe
% dieser können Operationen automatisiert werden. Wenn z.B. eine der Rechnungen
% aus dem letzten Paragraphen heruntergeladen wurde, kann diese mittels Skript
% umbenannt, in den richtigen Ordner verschoben und der Todoliste ein Eintrag à la
% `Rechnung xy begleichen' hinzugefügt werden. In einer graphischen Umgebung ist
% diese Art von präziser Automatisierung nicht so einfach möglich.
%
% Experten mit viel Wissen und Erfahrung mit dem System wissen meist exakt welche
% Operation angewandt werden muss. In der Kommandozeile kann dies einfach und
% direkt eingetippt werden. Während selbst Experten in grafischen und Menü UI's
% sich immer durch die gleichen Menüs und Untermenüs klicken müssen.

% Westerman_1997:
%
% Command line interfaces provide a comparatively more powerful and more
% cognitively demanding means of command generation (Meister, 1989)
%
% In comparison with menu interfaces, they provide increased flexibility with
% respect to combinations of commands and parameters that may be Linked together
% (Norman, 1983), and a potentially more efficient means of generat- ing complex
% commands,

% Als Text-basiertes Interface kommt diesem die Klarheit von Worten zugute.
% Abstrakte Konzepte wie Marxismus lassen sich nur schwer bis gar nicht in Bildern
% beschreiben \parencite{Raskin_2008}, sind aber als Wort sehr umgänglich.

% TODO: graph much hard in the beginning but more performance later

\section{Die Terminal Umgebung}

Die moderne Kommandozeile existiert nicht mehr in Isolation. Um auf diese in
einem grafischen Fenstersystem zugreifen zu können wird ein \textbf{Terminal
Emulator} benötigt. Wie der Name schon preisgibt: es soll ein traditionelles
text-basiertes Terminal nachgebildet werden. Als grafische Anwendung besteht
aber der Vorteil die Maus zum Klicken oder Markieren verwenden zu können. In
diesem Terminal läuft eine Shell. So nennt man das Programm welches die Befehle
entgegennimmt und deren Resultate ermittelt und ausgibt. Am weitesten Verbreitet
sind Unix Shells wie \codeinline{bash} oder \codeinline{zsh}.
% TODO: Unix?
Die Sprache der Shell gesprochen ist Shell Script. Dessen Funktionsumfang
variiert je nach Shell Dialekt. Die meisten Unix Shells implementieren aber den POSIX
Standard und teilen deshalb eine gewisse Grundfunktionalität. DOS und andere
Windows Shells sind hier außen vor. Diese teilen weder Funktionalität noch Core
Utilities mit den Unix Shells. Die \codeinline{coreutils} sind Grundlegende
Werkzeuge zur Datei- und Textmanipulation \parencite{coreutils}, wie z.B.
\codeinline{ls}, \codeinline{cat} oder \codeinline{rm}.

% TODO: more citations
% TODO: unix philsophy here

\medskip

Neben der Shell gibt es noch andere Kommandozeilen Umgebungen. So gibt es
für viele Programmiersprachen eine Kommandozeile (z.B. für Node.js, Python
oder Scala). In diesen können dann nach gleichem REPL Schema Befehle in der
Programmiersprache interaktiv geschrieben und ausgeführt werden.

\section{Begrifflichkeiten der Kommandozeile}

Für ein Verständnis des CLI sind ein paar Begriffe zu definieren. Ein Shell
Befehl kann auf seine Einzelteile herunter gebrochen werden:

\begin{code}
  \begin{shellcode}
$ cd Downloads
$ git commit -m "Inital commit"
  \end{shellcode}
\end{code}

Das \codeinline{\$} zu Beginn bezeichnet das nachfolgend Shell Code kommt. In
der ersten Zeile ist \codeinline{cd} das Kommando was verwendet werden soll.
Gefolgt von einem Argument, etwas das dem Kommando übergeben wird. In diesem
Falle der Name eines Ordners (names \codeinline{Downloads}.) Die Reihenfolge
ist dabei bei mehreren Argumenten entscheidend. In der zweiten Zeile wird
dem \codeinline{git} Kommando das Subkommando \codeinline{commit} übergeben
(\cite{nagarajan2018}, \cite{clig}.)

\smallskip

Nicht alle CLIs haben Subkommandos. \cite{12factor} definiert zwei verschiedene
Arten von CLI Apps: ``single and multi-command''. Also klassische `UNIX-Style'
Werkzeuge wie \codeinline{cd}, \codeinline{cp} oder \codeinline{grep}. Und jene
Apps mit Subkommandos wie \codeinline{npm} oder \codeinline{git}, die meist
moderner und komplexer sind.

\smallskip

Zurück zu obigen \codeinline{git} Befehl: Dem \codeinline{commit} Subkommando
wird die \codeinline{-m} Flagge und mit Ihr ein Parameter (die Nachricht
\codeinline{Inital commit}) übergeben. Die \codeinline{-m} Flagge ist die
Kurzversion der langen \codeinline{--message} Flagge. Kurze Flaggen bestehen
immer aus Bindestrich und einem Buchstaben. Lange Flaggen starten mit zwei
Bindestrichen gefolgt von einem oder mehr Wörtern (meist sind mehrere Wörter
auch durch Bindestriche verbunden, z.B. \codeinline{--non-interactive}.)
Funktionell sind beide Flaggenvarianten identisch. Flaggen die keinen Parameter
erfordern werden als Boolean Flagge bezeichnet, deren An- oder Abwesenheit
meist etwas an- oder abschaltet. Die Reihenfolge der Flaggen untereinander ist
irrelevant (\cite{nagarajan2018}, \cite{clig}.)

\chapter{Probleme des Kommandozeilen Interface}
\label{sec:cli-problems}
\newcounter{prob}

Die Usability Schwierigkeiten des Kommandozeilen Interfaces lassen sich auf zwei
fundamentale Probleme zurückführen.

\section{Erinnern von Kommandos}

`Command recall' beschreibt die Problematik das ein Nutzer zum Verwenden eines
Programmes in der Kommandozeile immer dessen Namen kennen muss. Dies gilt für
Kommandos, deren Subkommandos und Flaggen aber auch für die Reihenfolge von
Argumenten \parencite{Raskin_2008}.

\bigskip

\newcommand{\refcr}[1]{\hyperref[prob:cr]{#1}}
\newcommand{\refcrr}{\hyperref[prob:cr]{`Command Recall'}}
\fbox{\parbox{\linewidth}{
  \refstepcounter{prob}
  \label{prob:cr}
  \textbf{Problem~\ref{prob:cr}}: Erinnern von Kommandos, Subkommandos, Flaggen und Argumenten.
}}

\bigskip

Dieses fundamentale Problem bedeutet das sich die Nutzer immer erst mit einem
Kommando auseinander setzten müssen bevor sie dieses verwenden können. Auch
spielt das Vergessen mit der Zeit eine große Rolle. \cite{Raskin_2008} weißt
auch auf teilweise geringe Einprägsamheit von Befehle wie \codeinline{tar -xzf
FILE}\footnote{Entpacken einer `gzipped tar' Datei (\codeinline{tar.gz}).} hin.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{empty-prompt.png}
  \caption{Die Shell bietet nichts an. Ohne ein Kommando zu kennen passiert nichts.}
\end{figure}

\cite{Gentner_1996} beschreiben auch den Fakt das es keinen einfachen Weg zum
Auffinden von Kommandos gibt. Der Nutzer muss also den Namen des Programmes
kennen um dieses zu nutzen oder auf dessen Hilfsseite oder `man page' zugreifen
zu können.

\section{Syntax und Semantik}

``Commands and associated parameters must be typed, maintaining the correct
semantic content and syntactic form.'' \parencite[184]{Westerman_1997}

\bigskip

\newcommand{\refss}[1]{\hyperref[prob:ss]{#1}}
\fbox{\parbox{\linewidth}{
  \refstepcounter{prob}
  \label{prob:ss}
  \textbf{Problem \ref{prob:ss}}: Einhalten der richtigen Syntax and Semantik.
}}

\bigskip

Die Kommandozeile gilt als sehr starr und wenig Tolerant gegenüber imperfekter
Syntax \parencite{Gentner_1996}.
Diese Syntaxfehler können vielerorts und sehr einfach auftreten. Probleme entstehen etwa bei:

\begin{itemize}
  \item Rechtschreibfehlern in Kommando, Subkommando, Flaggen oder übergebenen Dateien
  \item Durch das Weglassen benötigter Argumente bei Flaggen oder (Sub-) Kommandos
  \item Missachtung der Reihenfolge (von Argumenten oder Subkommandos, Flagge in Beziehung zu Subkommando oder Argument)
  \item Missachtung der Shell Regeln (etwa durch Weglassen von Anführungszeichen bei Argument mit Leerzeichen)
\end{itemize}

Vor allem wenn das Wissen um die impliziten Regeln der Shell fehlen, können
schnell komplizierte Fehler auftreten. Je nach Qualität der Fehlermeldung und
Erfahrung reißen die Syntaxfehler den Nutzer mehr oder weniger aus dem Flow.

\begin{code}
  \begin{shellcode}
$ git comit -m "Add commit"
git: 'comit' is not a git command. See 'git --help'.

The most similar command is
        commit
  \end{shellcode}
  \captionof{listing}{Fehlerhafter Subkommando Name bei \codeinline{git}. Mit hilfreicher Fehlermeldung.}
  \medskip
\end{code}

\bigskip

Semantische Probleme können auch auftreten. Meist sind diese Folge eines
Logikfehlers oder dem Durcheinanderbringen der Reihenfolge.

\begin{code}
  \begin{shellcode}
$ git add remote origin git@github.com:jneidel/oraclett.git
  \end{shellcode}
  \captionof{listing}{Ein syntaktisch valider \codeinline{git} Befehl der aber nicht tut was gemeint war.}
  \label{lst:add-remote}
  \medskip
\end{code}

Der Semantische Fehler im obigen Listing \ref{lst:add-remote} liegt im
durcheinanderbringen der \codeinline{add} und \codeinline{remote} Subkommandos.
\codeinline{git remote} ist zum Verwalten von `tracked repositories'.
\codeinline{git add} markiert eine Datei für den nächsten `commit'. Je nach
Kontext haben \codeinline{add} und \codeinline{remote} eine andere Bedeutung.
\codeinline{git remote add} fügt eine neue `repository' hinzu während
\codeinline{git add remote} aber eine Datei mit dem Namen \codeinline{./remote}
für den nächsten `commit' markiert.

\smallskip

Durch eine kleine Veränderung der Reihenfolge entsteht eine völlig andere
Bedeutung.

\section{Adressierung der Probleme durch Weiterentwicklungen}
\label{sec:weiterentwicklungen}

Die Lösungen zu den Probleme der Kommandozeile wurden vielfach in der Schöpfung
neuer Interface Typen gesucht. Ob innerhalb des Terminals oder außerhalb der
Text-basierten Welt.

\subsection{Innerhalb des Terminals}

Obwohl diese Evolutionen in der Kommandozeilenumgebung blieben, brachen sie
trotzdem mit der klassischen CLI Tradition. Die Unterscheidungen zwischen CLI
und `menu-driven'/dem interaktivem Interface sind dabei trotzdem nicht glasklar,
sondern eher verschwommen \parencite{Paap_1988}. Auch weil Aspekte des CLI (wie
Hilfsseiten/man pages, Flaggen, etc.) weiterhin Teil dieser Applikationen sind.
Auch weil sich die verschiedenen Interfaces ergänzen und zusammen besser seinen
können als in ihrer Reinform.

\smallskip

\cite{bland2007design} beispielsweise implementieren neben dem reinen
nicht-interaktiven CLI Workflow noch einen menü-basierten Modus in welchem der
Nutzer mit ``menus similar to those of the GUI'' durch den Prozess geführt wird.

\subsubsection{Menü-basiertes Interface}
\label{sec:def-menu}

Das Menü oder auch `Text-based user interface' (TUI) ähnelt dem GUI insofern als
das dem Nutzer die Optionen visuell präsentiert werden. Anders als im GUI werden
dafür aber nur Textelemente verwendet. Mausinteraktion wird von modernen TUI's
aber unterstützt. Da zur Implementation historisch oft die `curses' Bibliothek
verwendet wurde ist es auch als `curses' Interface bekannt.

\medskip

\begin{figure}[H]
  \centering
  \includegraphics[scale=.47]{menu-example.png}
  \caption{Beispiel eines TUI: Emails im Terminal mit \codeinline{neomutt}.}
  \label{fig:menu-example}
\end{figure}

Laut \cite{Paap_1988} wandelt das Menü das Problem des
\hyperref[prob:cr]{`Command Recall'} in `Command
Recognition', ein Wiedererkennen, um. Auch werden die Anfälligkeit für
\hyperref[prob:ss]{Syntaxfehler} reduziert, weil der Nutzer vor
illegalen Optionen abgeschirmt wird \parencite{Kantorowitz_1989}.

\smallskip

Im einem vergleichenden Experiment mit der Kommandozeile stellte
\cite{Westerman_1997} für manche Nutzergruppen unsignifikant bessere Performance
fest. Auch wurde bei freier Wahl das Menü über alle Nutzergruppen hinweg doppelt
so häufig zur Nutzung ausgewählt.

\smallskip

Verglichen mit der GUI sind TUI's trotzdem für Anfänger trotzdem schlechter
(in Performance und Meinung). Bei Experten liegen beide gleichauf
\parencite{tuivsgui}.

\subsubsection{Interaktive CLI}
\label{sec:def-interactive}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{interactive-example.png}
  \caption{Ein Interaktive CLI leitet durch eine Pizza Bestellung.}
  \label{fig:interactive-example}
\end{figure}

Die Interaktive CLI basiert auf einem ``question and answer model''
\parencite[42]{Spolsky_2001}. Dem Nutzer werden kontinuierlich Fragen gestellt
auf dieser er antwortet (siehe Abbildung \ref{fig:interactive-example}.) Durch
die hilfreichen Fragen entfällt der Bedarf sich an Kommandos erinnern zu müssen
(vgl. \hyperref[prob:cr]{`Command Recall'}.)

\smallskip

Je nach Bedarf kann der Nutzer nach einfachem Text-Input oder Zahlen
gefragt werden. Auch komplexeres wie dem Auswählen aus einer Liste oder
`multiple-choice` Fragen sind möglich (vgl. Abbildung \ref{fig:interactive-example2}.)

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{interactive-example2.png}
  \caption{Der Belag einer Pizza wird interaktiv zusammenstellt.}
  \label{fig:interactive-example2}
\end{figure}

\subsection{Außerhalb des Terminals}
\label{sec:weiterentwicklung-ausser}

Historisch wurde die grafische Benutzeroberfläche als Lösung für die Probleme
der CLI gesehen (vgl. Kap. \ref{sec:historic-context}.) So wurden dem Nutzer die
möglichen Optionen grafisch präsentiert, anstatt diese nachschauen zu müssen.
(vgl. \hyperref[prob:cr]{`Command Recall'}.)

\smallskip

Es vollzog sich damit ein Wechsel von der Funktions-orientierten
Kommandozeile hin zum Objekt-orientierten GUI \parencite{nielson1993}. Die
Funktions-orientiertheit drückt sich etwa durch die in `single-command' CLI's
häufig vertretene Verb-Nomen Struktur aus. Beispielsweise in \codeinline{rm
FILE} oder \codeinline{cat FILE}. In der Objekt-orientierten Welt gehen alle
Aktionen vom Objekt aus. So wird eine Datei in den Papierkorb gezogen (vgl.
\codeinline{rm FILE}) oder per Doppelklick angezeigt (vgl. \codeinline{cat
FILE}). Semantische Probleme (wie mit \codeinline{mv} die Reihenfolge
durcheinander zu bringen) sind damit passé. Und von der Textform befreit sind es
auch die in der CLI prävalenten \hyperref[prob:ss]{Syntaxfehler}.

\smallskip

Aber auch das grafische User Interface hat seine Schwächen. Und diese werden vor
allem `at scale' sichtbar. Die Massen des Internets lassen sich nicht grafisch
darstellen und auch ein volles Email Postfach ist mit nur grafischen Werkzeugen
wenig durchsichtig. \cite{Norman_2007} beschreibt wie Suchmaschinen hier einen
Ausweg bieten. Und nennt sie `answer engine'. Eine flexiblere, robustere und
getarnte Kommandozeile die mit Rechtschreibfehlern und Synonymen umgehen kann.

\chapter{Entwicklung von Methoden}
\label{sec:methods}
% TODO: intro here
% Methoden beziehen sich direkt auf ein Problem welches adressiert werden soll.

\section{Methodologie}
% [Beschreibung des geplanten Vorgehens(-modells) zur Lösung der Problemstellung; umfasst u.a.:

Nach Betrachtung der \hyperref[sec:cli-problems]{Probleme} sollten in
Literaturrecherche Lösungsansätze erarbeitet werden. Welche zusammen mit einer
Erklärung als Methoden formuliert wurden.

\smallskip

Auf der Abstraktionsskala von Softwarekonzepten befindet sich die Methode in der
Mitte zwischen abstrakt und konkret.

\begin{code}
  \begin{shellcode}
abstrakt <-----------------------> konkret
   Prinzip <---> Methode <---> Werkzeug
  \end{shellcode}
  \captionof{listing}{Abstraktionsskala von Softwarekonzepten.}
  \medskip
\end{code}

Das abstrakte und allgemeine Prinzip \parencite{Balzert_2009} wäre zu
philosophischer Natur gewesen um im nächsten Schritt angewandt zu werden.
Werkzeuge nach \cite{Balzert_2009} sind zu konkret und real. Es nicht Ziel ist
für jeden Lösungsansatz ein direkt anwendbares Werkzeug zu kreieren.

\medskip

Eine Methode nach \cite{Balzert_2009} ist eine begründete Vorgehensweise zur
Erreichung festgelegter Ziele. Sie ist nicht deskriptiv wie ein Werkzeug, und
nicht philosophisch wie ein Prinzip, sondern gibt eine Handlungsanweisung die
dem Entwickler Spielraum in der Implementierung lässt.

\medskip

Die zu formulierenden Methoden sollten sich daher: auf Probleme die durch sie
gelöst/gemindert werden beziehen. Und begründet darstellen warum dieser Effekt
eintreten wird.

\medskip

Nachfolgend nun die erarbeiteten Methoden.

% TODO: unterliegende philosophie/prinzipien hier

\newcounter{meth}
\newcommand{\methbox}[2]{
  \medskip
  \fbox{\parbox{\linewidth}{
    \refstepcounter{meth}
    \textbf{Methode~\themeth}: #2
    \label{meth:#1}
  }}
  \medskip
}
\newcommand{\methref}[1]{
  Methode~\ref{meth:#1}
}

\section{Flaggen anstatt Argumenten}

Sobald ein (Sub-) Kommando mehr als ein Argument annimmt, biete sich die
Gelegenheit die für Argumente relevante Reihenfolge durcheinander zu bringen
(vgl. \refss{Syntax/Semantik}.) \cite{12factor} empfiehlt deshalb bei zwei
oder mehr Argumenten anstatt dieser Flaggen zu verwenden. Das ist etwas mehr
Aufwand zum Schreiben, eliminiert aber die Reihenfolge als Fehlerfaktor.
Außerdem können Flaggen auch mittels Autovervollständigung vorgeschlagen werden
(vgl.~\methref{autocomplete}).

\methbox{flags_over_arguments}{Verwende Flaggen wenn mehr als ein Argument benötigt wird.}

Dies trifft vor allem zu wenn ein (Sub-) Kommando gleichzeitig Parameter über
Flaggen und Argumente entgegennimmt.

\begin{code}
  \begin{shellcode}
# Argument und Flaggen Kombination
$ oraclett project add INTPD999DXD --taskDetail "01 - Career development"

# Nur Flaggen
$ oraclett project add --project INTPD999DXD --taskDetail "01 - Career development"
  \end{shellcode}
  \captionof{listing}{Argument ersetzt durch Flaggen: vorher und nachher}
  \medskip
\end{code}

Außen vor sind Kommandos welche eine variable Anzahl von Argumenten annehmen.
Beispielsweise \codeinline{rm} dem mehrere Dateien zum Löschen übergeben
werden können. Hier handelt es sich aber nicht um Argumente mit verschiedenen
Bedeutungen (\cite{12factor}.)

\medskip

Ein weiter Vorteil ist das Erstellen von Aliasen to vereinfachen. Das sind
Abkürzungen die ein Nutzer sich innerhalb seiner Shell definieren kann. Etwa um
ein Kommando abzukürzen: \codeinline{alias v="nvim"} macht \codeinline{nvim} mit
dem Kommando \codeinline{v} nutzbar.

\smallskip

Man stelle sich vor ein CLI App nimmt ein eine Anzahl von Stunden und ein Datum:

\begin{code}
  \begin{shellcode}
$ app HOURS DATE
  \end{shellcode}
\end{code}

Und der Nutzer möchte einen Alias mit dem für den heutigen Tag eine Anzahl von Stunden übergeben wird.
Gewünschte Nutzung des Alias sieht so aus:

\begin{code}
  \begin{shellcode}
$ apptoday 8
  \end{shellcode}
\end{code}

Um diesen Alias zu ermögliche muss aber eine kompliziertere\footnote{Neulinge
kommen mit der Alias Syntax meist früher in Kontakt. Neben unvertrauter Syntax
spielt mit hinein das Shell Argumente (\codeinline{\$1}) verwendet werden müssen und das die
Möglichkeit entfällt dynamisch weitere Flaggen zu übergeben.} Shell Funktion
definiert werden, weil das Argument an die richtige Stelle übergeben werden
muss:

\begin{code}
  \begin{shellcode}
apptoday() {
  app $1 today
}
  \end{shellcode}
\end{code}

Wäre die App dagegen mit Flaggen anstatt Argumenten konzipiert und würde folgenden
Nutzung haben:

\begin{code}
  \begin{shellcode}
$ app --hour HOURS --date DATE
  \end{shellcode}
\end{code}

Dann wäre der Alias viel leichter und flexibler zu definieren:

\begin{code}
  \begin{shellcode}
$ alias apptoday="app --date today --hour"
  \end{shellcode}
\end{code}

Wenn die Stunde anstatt des Tages durch den Alias festgeschrieben werden soll,
ist das mit der Flaggen-basierten Struktur auch kein Problem. Der Nutzer ist
unabhängig von der durch den Entwickler definierten Reihenfolge.

\section{Unterstützung aller Hilfs- und Versionsflaggen}

Der Großteil aller Apps bietet eine Hilfs- und eine Versionsseite. Hilfsseiten
beschreiben ähnlich wie eine `man page'\footnote{Einer über das \codeinline{man}
Kommando verfügbaren Hilfsseite.} die Subkommandos, Flaggen und Syntax. Meist
sind diese auch relativ und beziehen sich auf das aktuelle Subkommando.
Versionsseiten geben die Version der App\footnote{Sowie ggf. eine Liste von
optionalen Features die mit einkompiliert wurden.} wieder.

\begin{code}
  \begin{shellcode}
$ mullvad status --help
mullvad-status
View the state of the VPN tunnel

USAGE:
    mullvad status [OPTIONS] [SUBCOMMAND]

OPTIONS:
        --debug       Enables debug output
    -h, --help        Print help information
    -l, --location    Prints the current location and IP. Based on GeoIP lookups
    -v                Enables verbose output

SUBCOMMANDS:
    listen    Listen for VPN tunnel state changes
  \end{shellcode}
  \captionof{listing}{Als Beispiel: Die gekürzte, relative Hilfsseite von \codeinline{mullvad status}.}
  \medskip
\end{code}

Beim Aufrufen dieser Seiten haben Nutzer ihre Präferenzen wenn es darum geht
welche Flagge sie verwenden um diese angezeigt zu bekommen.

\begin{code}
  \begin{shellcode}
$ app -h
$ app --help
$ app help

$ app -v
$ app -V
$ app --version
$ app -version
\$ app version
  \end{shellcode}
  \captionof{listing}{Gängige Varianten der Hilfs- und Versionsflaggen.}
  \medskip
\end{code}

Laut \cite{12factor} sollten möglichst alle Varianten in von einer Anwendung
unterstützt werden. So kann vermieden werden das der Nutzer nicht das angezeigt
bekommt wonach er sucht. Das Problem des \refcrr wird vermieden weil der Nutzer
durch Probieren seiner präferierten Variante direkt zur Lösung kommt.

\methbox{support_all_help_version}{Unterstütze alle gängigen Formen der Hilfs- und Versionsflaggen.}

\newcommand\checkmark{\ttfamily{\char"2611}}
\newcommand\cross{\ttfamily{\char"2610}}
\begin{table}[h!]
  \begin{center}
    \label{tab:help_version}
    \begin{tabular}{l | c c c | c c c c c}
      Kommando & \codeinline{-h} & \codeinline{--help} & \codeinline{help} & \codeinline{-v} & \codeinline{-V} & \codeinline{--version} & \codeinline{-version} & \codeinline{version} \\
      \hline
git & \checkmark & \checkmark & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark\\
node & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross & \cross\\
mullvad & \checkmark & \checkmark & \cross & \cross & \cross & \cross & \cross & \checkmark\\
grep & \cross & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross & \cross\\
zathura & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross & \cross\\
tsp & \checkmark & \cross & \cross & \cross & \checkmark & \cross & \cross & \cross\\
pubs & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \cross & \cross\\
ffmpeg & \checkmark & \checkmark & \cross & \cross & \cross & \cross & \checkmark & \cross\\
systemctl & \checkmark & \checkmark & \cross & \cross & \cross & \checkmark & \cross & \cross\\
pacman & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross & \cross\\
make & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \checkmark & \cross\\
synctex & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark\\
curl & \checkmark & \checkmark & \cross & \cross & \checkmark & \checkmark & \cross & \cross\\
ansible & \checkmark & \checkmark & \checkmark & \cross & \cross & \checkmark & \cross & \cross\\
nvim & \checkmark & \checkmark & \cross & \checkmark & \cross & \checkmark & \checkmark & \cross\\
      \hline
      Summe & 14 & 14 & 3 & 7 & 5 & 12 & 4 & 3 \\
    \end{tabular}
    \caption{Unterstützte Varianten von Hilfs- und Versionsflaggen bei einer Stichprobe von 15 Kommandos.}
  \end{center}
\end{table}

In einer unrepresentativen Stichprobe (siehe Tabelle) wurde
zusammengestellt welche Flaggen in 15 Anwendungen funktionieren bzw.
nicht funktionieren. Dabei stellte sich heraus das \codeinline{-h} und
\codeinline{--help} praktisch überall funktionieren. Mit \codeinline{--version}
wird in den meisten Fällen auch das gewünschte Ergebnis angezeigt. Aber wenn
\codeinline{--version} nicht zum Ziel führt ist durchprobieren angesagt.

\smallskip

Am wenigsten verbreitet sind \codeinline{help} und \codeinline{version},
welche aber auch etwas außen vor sind, weil das erste Argument bei vielen
`single-command' Kommandos eine `Input' Datei bezeichnet. Aber bei
`multi-command' Apps sollten auch diese Varianten unterstützt werden.

\section{Relevante Standardwerte}

Relevante `Defaults' sind nicht Kommandozeilen-spezifisch, können dort aber
wichtiger sein als in grafischen Anwendungen.

\smallskip

Dem Nutzer werden die Möglichkeiten eben nicht zur Auswahl gestellt und dieser
klickt die gewünschte Option an. Sondern ist das Auflisten der Möglichkeiten
i.d.R. ein separater Schritt, losgelöst von der eigentlich beabsichtigten
Aktion. Beispielsweise muss um sich mit \codeinline{cd} in einen Ordner
hineinzubewegen der Name dessen zuerst in Erfahrung gebracht werden (etwa mit
\codeinline{ls -d}.)

\smallskip

Es greift wieder das fundamentale Problem des \refcrr. Den Schritt des
Auflistens der Möglichkeiten (ähnlich wie das Auflisten von möglichen Kommandos)
ist ein extra Schritt der nur nötig ist weil der Nutzer sich nicht an die Option
erinnern kann die er verwenden möchte.

\bigskip

\methbox{relevant_defaults}{Biete relevante Standardwerte an.}

Dem Nutzer relevante Defaults anzubieten erlaubt es diesem weniger Argumente an
die CLI App übergeben zu müssen. Es gibt weniger Fehlermeldungen die den Nutzer
zurückweisen, weil dieser etwas vergessen hat.

\smallskip

Es ist aber auch elementar die Nutzung dieser Standardwerte zu kommunizieren.
Damit der Nutzer von ihnen nicht überrascht wird.

\section{Interaktives Nachfragen bei fehlendem Parameter}

Man stelle sich folgendes Szenario vor. Eine CLI hat ein Kommando welches einen
Parameter erfordert. Normalerweise erfolgt bei nicht-Übergabe dieses Parameters
eine Fehlermeldung welche darauf hinweist.

\begin{code}
  \begin{shellcode}
$ mullvad relay set location
error: The following required arguments were not provided:
    <country>

USAGE:
    mullvad relay set location <country> [ARGS]

For more information try --help
  \end{shellcode}
  \captionof{listing}{Fehlermeldung bei fehlendem Parameter in \codeinline{mullvad}'s CLI.}
  \label{lst:missing-param}
  \medskip
\end{code}

Die CLI weiß aber bereits was der Nutzer tun möchte und könnte anstatt
der Fehlermeldung dem Nutzer mit einer Eingabeaufforderung (interaktivem
Nachfragen, vgl. Kapitel \ref{sec:def-interactive}) nach dem fehlenden
Parameter fragen \parencite{12factor}. Oder, je nach Kontext, diesem sogar
eine Liste von Vorschlägen geben, um daraus auswählen. Dem Nutzer wird erspart
sich damit auseinander zu setzen welche Parameter erfordert sind (vgl.
\hyperref[prob:cr]{`Command Recall'})

\methbox{interactive_missing_param}{Frage bei fehlendem Parameter interaktiv nach.}

\begin{code}
  \begin{shellcode}
$ mullvad relay set location
Enter location country code:
  \end{shellcode}
  \captionof{listing}{Beispiel der Eingabeaufforderung zur Verbesserung von Listing \ref{lst:missing-param}.}
  \medskip
\end{code}

Fairerweise ist zu bemerken das die mullvad CLI dies auch, an anderer Stelle,
genau so handhabt. Bei \codeinline{mullvad account login} wird nach der
fehlenden Accountnummer gefragt.

\medskip

Mit einer Fehlermeldung anstatt des interaktivem Nachfragens könnte der
Nutzer leichter auf die ggf. komplexere Verwendung des Kommandos hingewiesen
werden. So nimmt das mullvad Kommando aus dem ersten Beispiel neben der
Landeskennung auch noch optional die ein Stadt- und `Hostkennung'. Was aber
aus der Fehlermeldung auch nicht klar hervorgeht. Wenn unter Berücksichtigung
dieser Methode implementiert wird kann dieser Einwand aber auch mitigiert
werden. Entweder durch das Vereinfachen oder Umgestalten der Kommandos. Oder mit
Hinweisen auf die Hilfsseite, welche die Parameter vollumfänglich erklärt.

\section{Natürliche Sprache}
\label{sec:natural-lang}

\cite{Raskin_2008} beschreibt die Kapazitäten linguistischer
Kommandozeilen, welche Normans Konzept der `answer engines' (vgl. Kapitel
\ref{sec:weiterentwicklung-ausser}) ähneln. Diese haben wie der Name schon
hergibt einen Fokus auf menschlicher Sprache\footnote{Die Linguistik ist das
Studium der menschlichen Sprache.}. Ein schönes, genanntes Beispiel von Google
Calendar für die Stärke solcher, auf natürlicher Sprache basierender Interfaces:
``Sunday dinner at 7:30 p.m. with Asa Jasa.'' Es werden keine Kommandos
verwendet. Das gewünschte wird einfach in natürlicher Sprache beschrieben.
Syntax ist nur insofern relevant, als das die menschliche Sprache ihre eigene
Syntax hat.

\medskip

``Recently, there has been a growing movement that sees today's command line
as a human-first text-based UI, rather than a machine-first scripting platform
\parencite{clig}'' - \parencite{Schr_der_2021}

\medskip

Die Syntax- und Semantikeinschränkungen des Kommandozeilen Interfaces lassen
eine alleinig `human language'-gestützte Anwendung nicht zu. Zumindest nicht
der Reinform des CLI. Als `human-first` User Interface sollte trotzdem
zumindest eine eingschränkte Form natürlicher Spracheingabe unterstützt werden
\parencite{seneviratne2008new}.

\methbox{human_language}{Unterstütze Eingaben in natürlicher Sprache.}

\section{Fehlerkorrektur}

Diese Methode zeigt eine gewisse Nähe zur Unterstützung der natürlichen
Sprache (Kapitel \ref{sec:natural-lang}). So hob \cite{Raskin_2008} für die
linguistische Kommandozeile die Verträglichkeit von Rechtschreibfehlern hervor.

\smallskip

Fehlertoleranz im Bezug auf Rechtschreibung würde auch das Problem der zu
\refss{strikten Syntax} zum Teil adressieren. Fehlermeldungen und die damit
einhergehende Frustration minimieren. \cite{clig} empfehlen ganz konkret: ``If
the user did something wrong and you can guess what they meant, suggest it.''
Im Kontrast dazu soll nach der `Do what I mean' Philosophie der Fehler direkt
und ohne Nutzerfeedback ausgebessert werden \parencite{DWIM}. Was natürlich
schneller ist und den Nutzungsflow nicht unnötig unterbricht. \cite{clig} weisen
aber auch darauf hin das eine fehlerhafte Eingabe neben Rechtschreibfehlern eben
auch aus logischen Fehler resultieren kann. Dann kann `Do what I mean' zu sehr
unerwartetem, gefährlichem Verhalten führen.

\methbox{typos}{Unterstütze (suggestive) Fehlerkorrektur.}

\begin{code}
  \begin{shellcode}
heroku pss
 ›   Warning: pss is not a heroku command.
Did you mean ps? [Y/n]:
  \end{shellcode}
  \captionof{listing}{Korrekturvorschlag eines Rechtschreibfehlers nach \cite{clig}.}
  \medskip
\end{code}

\section{Autovervollständigung}

`Auto-completion' in der Kommandozeile beschreibt das beim Drücken der `TAB' Taste
etwas ergänzt/vervollständigt wird.

\smallskip

In der Shell funktioniert dies etwa für Kommandos und Dateipfade:
\begin{code}
  \begin{shellcode}
$ wg # Nutzer drückt TAB
$ wget

$ cat ./note # Nutzer drückt TAB
$ cat ./notes.md
  \end{shellcode}
  \captionof{listing}{Autovervollständigung in der Shell.}
  \medskip
\end{code}

Innerhalb einer CLI App kann die Vervollständigung, neben Dateipfaden, auch
Subkommandos und Flaggen umfassen.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{mullvad-autocomplete.png}
  \caption{\codeinline{mullvad}'s CLI listet nach dem drücken von `TAB' mögliche Subkommandos.}
  \label{fig:autocomplete}
\end{figure}

`Auto-completion' adressierte beide Probleme welche das CLI mit sich bringt.
Durch das Vorschlagen und Vervollständigen wird das \refcr{Erinnern}
erleichtert. Und dadurch das nur valide Kommandos vorgeschlagen werden ist das
einhalten von \refss{Syntax- und Semantikregeln} erleichtert. Auch profitiert
der Nutzer von Kontext-bezogenen Beschreibungen.

\methbox{autocomplete}{Nutze Autovervollständigung zum Vorschlagen von Flaggen
und Subkommandos \parencite{seneviratne2008new}.}

In \cite{dutta} geht der Author sogar noch einen Schritt weiter und empfiehlt
das automatische Vorschlagen aller Flaggen und Argumente für ein Kommando,
sodass der Nutzer sich nicht mal anschauen muss was für das Kommando benötigt
wird. So wie vom Author beschrieben ist dies aber nicht in der Shell möglich,
sondern müsste in einer eigenen Kommandozeilen Umgebung umgesetzt werden.

\section{Menü-basiertes Interface}

Im Kapitel \ref{sec:def-menu} wurde schon darauf eingegangen wie ein
TUI die Probleme der Kommandozeile adressieren würde. Auch wurde eine
klare Präferenz für ein solches Interface unter den Nutzern festgestellt
\parencite{Westerman_1997}. Auch \cite{Spolsky_2001} nennt das Menü-basierte
Interface als einen Weg Usability zu erhöhen.

\methbox{menu}{Biete ein Menü-Interface an.}

\section{Relevante Kommandovorschläge}

Die Essenz von \refcrr ist das Nutzer nicht wissen welche (Sub-) Kommandos
ihnen zur Verfügung stehen. Kommandos existieren aber nicht im Vakuum. Im
Zusammenspiel unterliegen sie meist einer gewissen Reihenfolge bzw. einem
`Nutzungsflow'. Bevor in einen Ordner gewechselt werden kann (\codeinline{cd})
muss dieser erst existieren (\codeinline{mkdir}) oder der Nutzer muss um diesem
wissen (\codeinline{ls}). \cite{dutta} schlägt nun vor sich diesen `Flow'
zu nutze zu machen um den Nutzer über mögliche nächste Schritte (in Form
anderer (Sub-) Kommandos) zu informieren. Für den gegebenen `Flow' könnte
also \codeinline{mkdir} mit einer Nachricht à la \codeinline{Also look at -
cd, ls} versehen werden. Diese Vorschläge können als Erinnerung dienen oder
den Nutzer dazu Auffordern sich die Vorschläge einmal näher anzuschauen. Bei
`multi-command' CLI's mit vielen Subkommandos, wo der Nutzer nicht weiß wo er
anfangen soll, sind diese Vorschläge besonders wertvoll.

\methbox{command_recommendations}{Schlage dem Nutzer andere relevante
Subkommandos vor \parencite{seneviratne2008new}.}

\chapter{Beispiel Anwendung}
\label{sec:beispiel-anwendung}

\section{Anforderungsanalyse}
% [Beschreibung der Erhebung, Granularisierung und Priorisierung der zu Grunde liegenden Anforderungen]

Die zu bauende Anwendung wurde konzipiert nicht zu trivial - um genug
Spielraum im Interface Design zuzulassen - aber auch nicht zu komplex - um die
Umsetzbarkeit zu gewährleisten - zu sein.

\subsection{Konzept}
\subsubsection{Problem}

Bei Endava werden die Arbeitsstunden über ein Oracle System festgehalten. Dieses
glänzt nicht in Usability, es führt aber kein Weg dran vorbei.

% TODO: screenshot best case

Das System funktioniert so, dass ein mal wöchentlich die Zeiten der vergangen
Woche abgegeben werden müssen. In diesen Timecards wird angegeben an welchen
Wochentagen man wie viele Stunden an welchem Projekt gearbeitet hat. Bei einem
Projekt und 40 Stunden Woche ist das ausfüllen trivial. Aber sobald man seine
Zeit zwischen mehreren Projekten mit schwankender Stundenzahl aufteilt wird
es komplizierter. Außerdem wird teils gefordert sich Notizen zu machen woran
gearbeitet wurde. Zusammengenommen heißt dies: täglich müssen Dinge bei Oracle
eingetragen werden.

% TODO: screenshot realistic case

\subsubsection{Lösungsansatz}

Die entworfene Lösung ist eine Kommandozeilen App welche das tägliche loggen der
Arbeitszeiten, und Notizen woran gearbeitet wurde, vereinfacht. Und diese Daten
dann zum wöchentlichen Übertragen in Oracle in strukturierter Form ausgibt.
Dadurch wird erreicht nur das erforderliche Minimum der Zeit mit Oracle zu
verbringen, dessen Workflow im übrigen auch am besten funktioniert wenn alles in
einem Rutsch erledigt wird.
\\
Weil es den Rahmen sprengen würde, ohne dem Thema dienlich zu sein, wurde davon
abgesehen die CLI an ggf. bestehende Oracle APIs anzubinden.

\subsection{Anforderungen}

Die Anforderungen wurden in Form von User Stories festgehalten. Erhoben wurden
diese durch den Author in Analyse der eigenen Nutzungsmuster mit Oracle,
abgeglichen in Rücksprache mit anderen Mitarbeitern.

\begin{enumerate}
  \item \textbf{Projekte}:
    \begin{enumerate}
      \item Als Nutzer möchte ich ein Projekt hinzufügen.
      \item Als Nutzer möchte ich einem Projekt einen oder mehrere Task Details anfügen.
      \item Als Nutzer möchte ich die Projekte sowie deren Task Details aufgelistet sehen.
      \item Als Nutzer möchte ich Projekte und Task Details anpassen oder löschen können.
    \end{enumerate}
  \item \textbf{Arbeitszeit}:
    \begin{enumerate}
      \item Als Nutzer möchte ich meine Arbeitsstunden an einem Tag für eine Projekt-Task Detail Kombination loggen.
      \item Als Nutzer möchte ich die geloggten Arbeitsstunden einer gegebenen Woche einsehen.
      \item Als Nutzer möchte ich geloggte Arbeitsstunden anpassen oder löschen.
    \end{enumerate}
  \item \textbf{Arbeitsnotizen}:
    \begin{enumerate}
      \item Als Nutzer möchte ich festhalten woran ich gearbeitet habe.
      \item Als Nutzer möchte ich meine Notizen sehen können.
      \item Als Nutzer möchte ich meine Notizen für einen Tag bearbeiten oder löschen.
    \end{enumerate}
  \item \textbf{Report Generierung}:
    \begin{enumerate}
      \item Als Nutzer möchte ich einen Report für eine gegebene Arbeitswoche generieren, um die Daten in Oracle zu übertragen.
    \end{enumerate}
\end{enumerate}

Diese User Stories sollen einen Eindruck über die Anforderungen der App
und deren Komplexität vermitteln. Das Bauen der App steht aber nicht im
Vordergrund, weshalb u.a. hier die Akzeptanzkriterien der User Stories,
Implementationsdetails wie Datenpersistierung, etc. nicht weiter beschrieben
werden.

\section{Fundament}

Das Fundament der App stellen die zugrundelegenden technologischen Aspekte dar,
welche nicht oder nur indirekt die Nutzbarkeit, und damit den Fokus der Arbeit
betreffen.

Node.js wurde als Programmiersprache gewählt, weil der Author damit vertraut
war, eine Vielzahl von Libraries zum Bauen von CLI's existieren und der
Paketveröffentlichungsprozess mit npm relativ simpel ist. Weiterhin wurden noch
Typescript - für Typisierung - und Eslint - für gleichmäßigen Code Style -
verwendet.

\section{Libraries}

Ein Überblick über die Libraries welche für das Bauen des Interfaces und die
Umsetzung der Methoden relevant waren.

\subsection{oclif}

``oclif is an open source framework for building a command line interface
(CLI) in Node.js. Create CLIs with a few flags or advanced CLIs that have
subcommands.'' \parencite{oclif}

oclif biete ein System um ohne viel Boilerplate Kommandos zu bauen, dessen
Flaggen und Argumente zu beschreiben und dann eigene Businesslogik auszuführen
(siehe Abbildung \ref{fig:oclif-list}.) Während oclif Kommando- und
Flaggenparsing, das generieren der Hilfsseite uvm. übernimmt.

\begin{figure} % TODO: redo, as listing?
  \centering
  \includegraphics[scale=0.5]{oclif-list.png}
  \caption{Beschreiben eines Kommandos in oclif am Beispiel des implementierten \codeinline{project list} Kommandos}
  \label{fig:oclif-list}
\end{figure}

Die Hierarchie von Kommandos wird über eine Strukurierung der Dateien erreicht (siehe nachstehendes Listing) und der Feinschliff wird noch per Konfiguration in der \codeinline{package.json} erreicht.

\begin{code}
  \begin{shellcode}
 src/commands
 └── project
     ├── add.ts
     ├── edit.ts
     ├── list.ts
     └── remove.ts
  \end{shellcode}
  \captionof{listing}{Kommandohierarchie wird duch Dateistruktur angegeben: Am Beispiel von des \codeinline{project} Kommandos und dessen Subkommandos}
  \medskip
\end{code}

oclif kümmert sich auch um Kleinigkeiten. Zum Beispiel sicherzustellen das der
Text der Hilfsseiten richtig formatiert wird. Im unterstehenden Listing wird
demonstriert wie oclif bei eingeschränkter Breite des Terminals so einrückt
das immer noch klar zu erkennen ist was Beschreibung und was Flagge ist. Das
Gegenbeispiel dazu entsteht wenn einfach nur der Text geschrieben wird, ohne die
Terminalbreite zu berücksichtigen.

\begin{code}
  \begin{shellcode}
# in oclif
FLAGS
  -d, --date=<value>  [default: today] A date to specify the day OR
                      the week (can be human-readable)

# ohne Framework
FLAGS
  -d, --date=<value>  [default: today] A date to specify the day OR
the week (can be human-readable)
  \end{shellcode}
  \captionof{listing}{oclif's Handhabung von Zeilenumbrüchen in einem schmalen Terminal im Vergleich zu einer Implementierung ohne Framework}
  \label{lst:oclif-umbruch}
  \medskip
\end{code}

\medskip

Neben oclif wurde noch andere Frameworks/Libraries in Erwägung gezogen. U.a.
\href{https://github.com/tj/commander.js}{commander.js},
\href{https://github.com/yargs/yargs}{yargs},
\href{https://github.com/dthree/vorpal}{vorpal} und
\href{https://github.com/sindresorhus/meow}{meow}.
\\
In der Sektion \ref{sec:impl-autocomplete} zur Implementation der Autocompletion wird
auch noch auf die Auswirkung der Wahl des Frameworks eingegangen.

\subsection{Inquirer.js}

Inquirer ist eine Ansammlung von interaktiven Fragetypen (vgl. Kapitel
\ref{sec:def-interactive}).

Neben einfachen Fragen, wie Text einzugeben oder einen Eintrag aus einer
Liste auswählen, gibt es auch die angesprochenen `multiple-choice' (siehe
Abb. \ref{fig:interactive-example2}) Fragen oder das bearbeiten von Text im
präferierten Texteditor einträgt.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{inquirer-example.png}
  \caption{Ein Frage und Antwort Flow zum herausfinden was der Nutzer bearbeiten möchte.}
  \label{fig:inquirer-example}
\end{figure}

\begin{code}
  \medskip
  \captionof{listing}{Beispielcode für das Auswählen aus einer Liste.}
  \begin{javascriptcode}
const { whatToEdit } = await inquirer.prompt( [ {
  type   : "list",
  name   : "whatToEdit",
  message: "What do you want to edit?",
  choices: [
    {
      name : "Project Name",
      value: "project",
    },
    {
      name : "Task Details (of a project)",
      value: "taskDetail",
    },
  ],
} ] );

// wird zu:

? What do you want to edit? (Use arrow keys)
> Project Name
  Task Details (of a project)
  \end{javascriptcode}
\end{code}

\section{Vorstellung der Anwendung}

% TODO: how does this chapter look?
% TODO: texts to disjointed?
% TODO: describe npm package

Es folgt eine grobe Vorstellung der Implementierten App. Nachgehend wird
noch einmal seperat auf die Implementation der Methoden zur Absenkung der
Nutzungsschwelle eingegangen.

\medskip

Der Name der App `oraclett' ist kurz für `Oracle time tracker'. Gewählt wurde
dieser weil er 1) kurz und prägnant als auch 2) mit Autovervollständigung leicht
zu finden ist. Intern ist die Platform zu festhalten der Arbeitszeiten als
`Oracle` bekannt, deshalb sollte der Name des Programmes mit \codeinline{oracle}
beginnen damit beim drücken von TAB dann zu \codeinline{oraclett}
vervollständigt wird. Andere in Erwägung gezogene Varianten waren
\codeinline{oracle-time-tracker} oder \codeinline{ott}.

\begin{code}
  \medskip
  \captionof{listing}{Das Hilfsmenu der CLI App}
  \label{code:oraclett-help}
  \begin{shellcode}
  \$ oraclett --help

  Oracle time tracker

  VERSION
    oraclett/0.0.0 linux-x64 node-v19.2.0

  USAGE
    \$ oraclett [COMMAND]

  TOPICS
    hour      Log working hours.
    note      Note down what you worked on.
    project   Add a project code.
    timecard  Generate a report for filling out timecards.

  COMMANDS
    autocomplete  display autocomplete installation instructions
    help          Display help for oraclett.
    timecard      Generate a report for filling out timecards.
  \end{shellcode}
\end{code}

Die Kommandos sind nach dem `noun verb' Prinzip \parencite{clig} strukturiert.
Auf das Nomen, in unserem Fall etwa die Stunde (\codeinline{hour}), folgt
ein Verb wie hinzufügen, bearbeiten, entfernen oder auflisten. Diese Verben
sind bei allen Kommandos einheitlich. Zu bearbeiten eines Projekt wird ebenso
\codeinline{edit} verwendet wie beim bearbeiten einer Notiz.

\begin{code}
  \label{code:hours-help}
  \begin{shellcode}
  \$ oraclett hour --help

  Log working hours.

  USAGE
    \$ oraclett hour COMMAND

  COMMANDS
    hour add     Log working hours.
    hour edit    Edit the logged hours interactively.
    hour list    List all projects.
    hour remove  Remove logged hours interactively.
  \end{shellcode}
  \captionof{listing}{Hilfsseite des `hour' Kommandos}
  \medskip
\end{code}

Die vorgesehene Nutzungsflow wäre wie folgt. Wenn man einem neuen Projekt
zugewiesen wird fügt man dieses \codeinline{oraclett} mit \codeinline{project
add} hinzu.
\\
Im normalen Arbeitsalltag würde man gearbeitete Stunden mit \codeinline{hour
add} festhalten. Auch Notizen dazu woran gearbeitet wurde würden im Moment
selbst mit \codeinline{note add} dokumentiert werden.
\\
Am Ende Arbeitswoche würde mit \codeinline{timecard} ein Report erstellt, dessen
Daten dann in das interne Oracle System übertragen werden. Womit die Woche
abgeschlossen wäre.
\\
Zum Verwalten oder Ausbessern der Daten im System gibt es jetzt noch die
\codeinline{edit} und \codeinline{remove} Subkommandos. Diese stehen falls
benötigt zur Verfügung, sind aber nicht teil des normalen Workflows.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{project-add.png}
  \caption{Interaktives hinzufügen eines Projektes.}
  \label{fig:project-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{project-list.png}
  \caption{Auflisten der im System vorhandenen Projekte.}
  \label{fig:project-list}
\end{figure}

Die Farben für verschiedene Daten sind einheitlich über alle `list' Kommandos.
So sind die Codes die Referenzcodes Projekte und `Task Details' Grün
bzw. Blau. Dies ist u.a. in den Abbildungen \ref{fig:project-list} und
\ref{fig:note-list} zu sehen. Notizen werden mit Gelb markiert, etwa auf der
Abbildung \ref{fig:note-list}. Und Stundenanzahl sowie Wochentage werden mit
Magenta hervorgehoben, wie zu sehen in Abbildungen \ref{fig:hours-list} und
\ref{fig:timecard}.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{note-add.png}
  \caption{Hinzufügen von Notizen auf interaktivem und normalem Wege.}
  \label{fig:note-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{note-list.png}
  \caption{Die Auflistung der Notizen einer gewählten Woche.}
  \label{fig:note-list}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{hours-add.png}
  \caption{Loggen von Stunden. Beim Weglassen von Flaggen werden diese interaktiv erfragt.}
  \label{fig:hours-add}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{hours-list-real.png}
  \caption{Auflistung der festgehaltenen Stunden.}
  \label{fig:hours-list}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{timecard-real.png}
  \caption{Ein die ganze Woche zusammenfassender Report, welcher in seiner Struktur dafür ausgelegt ist in die Web-Oberfläche des internen Tools übertragen zu werden.}
  \label{fig:timecard}
\end{figure}

\chapter{Implementation der Methoden}
\label{sec:implementation}

Dieses Kapitel dient dazu zu dokumentieren wie die zuvor formulierten Methoden
angewandt wurden. Die Anwendung dient als ein Beispiel dafür wie die Methoden
implementiert werden könnten. Es wird ein besonderer Augenmerk auf Probleme
gelegt welche das anwenden der Methoden erschwerten.

\section{Flaggen anstatt Argumenten}

\methref{flags_over_arguments} wurde implementiert. Die Kommandos zum Hinzufügen
von Objekten haben zwischen 2-4 Werten die übergeben werden sollen.

\begin{code}
  \begin{shellcode}
\$ oraclett hour add --help

Log working hours.

USAGE
  \$ oraclett hour add [-t <value>] [-p <value>] [-d <value>] [-H <value>]

FLAGS
  -H, --hour=<value>        The number of hours to log. (1h: 1, 30min: 0.5, etc.)
  -d, --date=<value>        [default: today] The date for which to log (can be human-readable)
  -p, --project=<value>     A project code (it it's short version)
  -t, --taskDetail=<value>  The task details (in it's short version, e.g. 01)

DESCRIPTION
  Log working hours.

  Passing no arguments will start an interactive session.

  This will add to existing hours, if this command is run twice the hours logged will be doubly.

EXAMPLES
  \$ oraclett hour add
  \$ oraclett hour add -H 3
  \$ oraclett hour add -H 3 -p INTPD999DXD -t 01
  \$ oraclett hour add -H 3 -p INTPD999DXD -t 01 --date yesterday
  \$ oraclett hour add -H 10 -p INTPD999DXD -t 01 -d today --force
  \end{shellcode}
  \captionof{listing}{Hilfsmenü von \codeinline{hour add}}
  \medskip
\end{code}

Neben dem Wegfallen der Reihenfolge sind die Flaggen auch elementar für das
Zusammenspiel mit anderen Methoden. Wenn der Nutzer von Defaultwerten Gebrauch
machen oder fehlende Werte interaktiv ergänzen will, kann die spezifische Flagge
einfach weg gelassen werden. Mit Argumenten wäre dies nicht so möglich gewesen.



\section{Unterstützung aller Hilfs- und Versionsflaggen}

Im Bezug auf \methref{support_all_help_version} ist zu sagen das natürlich alle
gängigen Varianten verwendbar sind.

Mit oclif war dies sogar sehr einfach:
\begin{code}
  \begin{javascriptcode}
...
"oclif": {
  "additionalHelpFlags": [
    "-h",
    "help"
  ],
  "additionalVersionFlags": [
    "-v",
    "-V",
    "version"
  ],
  ...
  \end{javascriptcode}
  \captionof{listing}{Konfiguration von Hilfs- und Versionsflaggen für oclif in der \codeinline{package.json}.}
  \medskip
\end{code}

\section{Relevante Standardwerte}
\label{sec:impl_defaults}

% TODO: methbox nochmal hier?

Die \methref{relevant_defaults} wurde auf zwei Wegen implementiert. Einmal als
exakte Implementation. Und einmal als Weiterführung im Sinne der Methode.

\begin{code}
  \begin{shellcode}
-d, --date=<value>  [default: this week] A date to specify the week (can be human-readable)
  \end{shellcode}
  \captionof{listing}{Die mit default versehene \codeinline{--date} Flagge.}
  \medskip
\end{code}

Obiger Auszug aus dem Hilfsmenü von \codeinline{hour list} kommuniziert das
die \codeinline{--date} Flagge wenn nicht übergeben den Wert \codeinline{this
week} annimmt. Wird das Kommando \codeinline{hour list} ohne Flaggen aufgerufen
werden die Stunden der aktuellen Woche angezeigt. Natürlich kann auch ein
anderer Zeitraum übergeben werden, die aktuelle Woche wird aber am relevantesten
für die meisten Nutzer sein.

\medskip

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{hours-edit-defaults.png}
  \caption{Wenn nur eine Option zur Verfügung steht wird diese automatisch verwendet.}
  \label{fig:hours-edit-defaults}
\end{figure}

Wenn nur eine Option besteht wird diese automatisch gewählt und der Nutzer
darüber informiert. Am Beispiel von \codeinline{hour edit} in der Abbildung
\ref{fig:hours-edit-defaults} sieht das wie folgt aus. Der Standardwert für
das Datum ist \codeinline{today}. Wenn heute nur Stunden für eine einzige
Projekt-Task Detail Kombination festgehalten wurden ist dieses gemeint. Und
am gewählten Tag keine Stunden oder Notizen festgehalten wurden, wird in den
Wochenmodus gewechselt. Dieser erlaubt, wie auch in Abb. \ref{fig:day-week-mode}
zu sehen, das Auswählen eines Wochentages für etwas im System vorliegt.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{day-week-mode.png}
  \caption{Wechsel vom Tagesmodus, in den Wochenmodus welcher aus Wochentagen mit vorliegenden Daten auswählen lässt.}
  \label{fig:day-week-mode}
\end{figure}

Außerdem wurden eine Auswahl an häufigen geteilten Projekten eingebettet. Der
Nutzer hat immer noch die Möglichkeit diese zu entfernen, aber wahrscheinlich
werden diese von allen Anwendern früher oder später einmal benötigt. Darunter
sind u.a. Projekt Codes zum absolvieren von Trainings, internen Events und der
Bank (keinem kommerziellen Projekt zugeordnet).

\section{Interaktives Nachfragen bei fehlendem Parameter}

Wie schon in Abbildung \ref{fig:hours-add} zu sehen wurde die
\methref{interactive_missing_param} konsequent implementiert. So ist in der
Abbildung zu sehen wie die fehlenden Stunden- und Datumsangaben erfragt werden.

\medskip

% TODO: besonders das auswähle aus der Liste hervorheben

\section{Natürliche Sprache}
\label{sec:sol-natural-lang}

Die \methref{human_language} wurde primär durch die Eingabe von Daten in
natürlicher Sprache implementiert. So kann anstatt starrer Formate wie
\codeinline{MM/DD/YY} einfach \codeinline{Monday} geschrieben werden wenn
der Montag dieser Woche gemeint ist.

\begin{code}
  \medskip
  \captionof{listing}{Unterstützte Varianten der Datumsangabe.}
  \begin{shellcode}
  mon, last monday, monday two weeks ago, today, yesterday, tomorrow, aug 15
  \end{shellcode}
\end{code}

Eingaben wie \codeinline{Monday} oder \codeinline{yesterday} sind
keine absoluten Datumsangaben, sondern steht immer im Kontext dazu wann der
Befehl ausgeführt wird. Da aber der Fokus der Anwendung auf der aktuellen und
vergangenen Woche liegt besteht darin kein Problem (vgl. gewählte Standardwerte
beschrieben in Kap. \ref{sec:impl_defaults}). In der Evaluation zeigten sich die
Nutzer auch zufrieden damit auf diesem Wege Zeitpunkte zu beschreiben. Absolute
Datumsangaben werden aber natürlich auch unterstützt.

\medskip

Auch sollten Synonyme für Subkommandos ``erkannt'' werden. Gedacht war das
Einrichten von alternativen Namen bzw. Aliasen. So sollten Subkommandos
wie \codeinline{hour} auch als \codeinline{hours} erkannt werden. Oder
\codeinline{remove} als \codeinline{delete}, etc. Leider wurde dies von oclif
nur inkonsequent und verwirrend unterstützt. So können Flaggen ganz einfach mit
einem Alias versehen werden. Auch Kommandos haben diese Option, dabei würde aber
folgendes heraus kommen:

\begin{code}
  \medskip
  \captionof{listing}{Auszug aus dem Hilfsmenü von \codeinline{hour}. Subkommandos \codeinline{add} und \codeinline{log} teilen die gleiche Beschreibung.}
  \begin{minted}[
    linenos,
    numbersep=6pt,
    frame=lines,
    framesep=2mm,
    fontsize=\footnotesize,
    highlightlines={2,5}
  ]{shell}
  COMMANDS
  hour add     Log working hours.
  hour edit    Edit the logged hours interactively.
  hour list    List all logged hours.
  hour log     Log working hours.
  hour remove  Remove logged hours interactively.
  \end{minted}
\end{code}

Kommandos die als Alias markiert sind tauchen immer in den Hilfsseiten auf.
Dadurch wird die Liste weniger übersichtlich. Und der Nutzer weiß nicht was
der Unterschied ist. Es gibt aber von oclif keinen Wege diese zu verstecken.
Wessenwegen sich gegen diese potenziell Frustrationssparenden Aliase entschieden
wurde.

\section{Fehlerkorrektur}

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{did-you-mean.png}
  \caption{Beispiel der `Meintest du ..' Fehlerkorrektur.}
  \label{fig:did-you-mean}
\end{figure}

Um bei Tippfehler dem Nutzer aber trotzdem einen schnellen Weg zum ausführen des
richtigen Befehls zu geben wurde im Bezug auf \methref{typos} eine suggestive
Fehlerkorrektur eingebaut (siehe Abbildung \ref{fig:did-you-mean}.) Diese kommt
mitgeliefert als Plugin für oclif.

\medskip

Synonyme wie die in Kap. \ref{sec:sol-natural-lang} genannten \codeinline{hour}
$\leftrightarrow$ \codeinline{hours} die sich sehr ähnlich sind können
durch auch die Fehlerkorrektur verbessert werden (siehe Abbildung
\ref{fig:did-you-mean}.) Weiter entfernte wie \codeinline{remove}
$\leftrightarrow$ \codeinline{delete} funktionieren leider nicht. Da dem System
wahrscheinlich auch keine Synonymdatenbank unterliegt.

\section{Autovervollständigung}
\label{sec:impl-autocomplete}

Die \methref{autocomplete} und die damit verbundene Autovervollständigung ist
technisch gesehen implementiert, praktisch ist diese aber nicht nutzbar.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{apps-autocomplete.png}
  \caption{Problematisches Autovervollständigungsmenü der App}
  \label{fig:apps-autocomplete}
\end{figure}

Wie auf der Abbildung \ref{fig:apps-autocomplete} zu sehen ist bestehen einige
Probleme. Am offensichtlichsten sind die Doppelpunkte (`:`) zum Trennen
der Kommandos anstatt von Leerzeichen. Dies ist eine Konvention welche
so durch oclif vorgegeben wir (obwohl Leerzeichen viel weiter verbreitet
sind.) In der letzten Zeile wird als Beschreibung etwas von ``If a day is
specified [..]'' geschrieben. Es wurde nicht die Zusammenfassung verwendet
sondern ein Schnipsel aus dem Hilfsmenü. Welcher an dieser Stelle nur
verwirrend für den Nutzer ist. Und zu letzt wird in der Beschreibung der
ersten Zeile der Beginn des Satzes nicht großgeschrieben und in der zweiten
Zeile wird der Template String nicht evaluiert. Alle dieser Dinge sind nicht
konfigurierbar. Für eine ordentliche Vervollständigung müsste diese also
selbst gebaut werden. oclif erschwert dies aber für andere Libraries wie
\href{https://github.com/f/omelette/issues/52}{omelette}. Und die Completion
Dateien selbst in Shell zu schreiben, ohne den Zugriff auf die Quelldateien
welche die Struktur und Inhalte vorgeben, wäre sehr fehleranfällig.
\\
Die geringe Qualität dieser Autovervollständigung war beim initialen Testen
des Frameworks und dem Lesen der Dokumentation nicht ersichtlich. Und nach
der Implementation war es zu spät zu einem anderen Framework zu wechseln, bei
welchem möglicherweise eine bessere Autocompletion möglich gewesen wäre.
\\
Um Verwirrung bei den Endnutzer zu Vermeiden wurde die Funktionalität wieder aus
der App entfernt. Es ist leider enttäuschend von dieser Methode keinen Gebrauch
machen zu können.

\section{Menü-basiertes Interface}
\label{sec:impl-menu}

Bei der \methref{menu} zum Menü wurde sich gegen eine Implementierung
entschieden. Die Anforderungen hätten aber durchaus als Menü abgebildet werden
können. Das Interface wäre aber von dem Kommandozeilen Interface gänzlich
abgetrennt. Die Implementation und eine über beide Interfaces hinweg eine
konsistente Nutzungserfahrung zu gewährleisten würde einen, im Vergleich zum
Rest der App, unverhältnismäßigen Programmieraufwand mit sich bringen. Weshalb
sich aufgrund des zeitlichen Rahmens dagegen entschieden wurde.

\section{Relevante Kommandovorschläge}

\methref{command_recommendations} hat in der App keine Anwendung gefunden. Wie
auch in der Erklärung wiedergegeben spricht \cite{dutta} diese Empfehlung in
Hinsicht auf CLI's mit sehr vielen (Sub-) Kommandos aus. Die implementierte
Anwendung umfasst nur eine sehr limitierte Anzahl von Subkommandos. Aufgrund
dieser bereits gegebenen Übersichtlichkeit wurde sich gegen direkte Vorschläge
entschieden.

\medskip

In Fehlermeldungen wurde der Geiste der Methode aber angewandt. So verweist ein fehlendes Projekt etwa auf das Hinzufügen und Auflisten von Projekten hin (vgl. Abb. \ref{fig:recommendation-invalid-project}.)

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{recommendation-invalid-project.png}
  \caption{Vorschläge zum Hinzufügen und Auflisten von Projekten bei Angabe eines Invalides Projektnamens.}
  \label{fig:recommendation-invalid-project}
\end{figure}



\chapter{Evaluation}
\label{sec:evaluation}

\section{Design der Studie}

Es wurde ein Usability-Test durchgeführt. Laut \cite[36]{hegner2003} werden
dabei ``[..] konkrete Nutzungssituationen durch repräsentative Endnutzer
simuliert, um die Bedienbarkeit eines Produkts oder Prototypen zu überprüfen.''
Es wurde die implementierte CLI App der existierenden GUI Webapp gegenüber
gestellt. Die Teilnehmer haben in beiden Apps Aufgabenstellungen erfüllt und
dann die Attraktivität der Applikation bewertet. Das Ziel war es zu sehen
welchen Effekt die entwickelten und implementierten Methoden auf die Nutzbarkeit
der CLI hatten. Ob die, der Kommandozeile inhärente, Nutzungsschwelle abgesenkt
werden konnte. Die existierende GUI Webapp diente dazu als Maßstab gegen welchen
es die Usability und Performance der CLI zu vergleichen galt.

\subsection{Rahmenbedingungen}

Die Teilnehmer der Studie waren ebenso wie der Author Mitarbeiter bei der
Firma Endava. Dies war Voraussetzung um die Zugriffsrechte für die Nutzung der
interne Platform, mit welcher verglichen werden sollte, zu gewährleisten. Die
Teilnehmer waren mehr oder weniger mit dem zum Vergleich stehenden Webseite
vertraut. Und hatten diese schon für die zu testenden Tätigkeiten verwendet. Das
Verständnis der Anwendungsdomäne der Apps war gegeben. Alle Teilnehmer waren
Software Entwickler oder Entwicklungsnah. Expertise mit der Kommandozeile war
zwischen ``wird nur benutzt wenn es nicht anders geht'' und ``wird regelmäßig
verwendet''.
\\
Insgesamt wurden 6 Personen getestet. Laut \cite[11]{Spolsky_2001} ist ``[..]
five or six users [..] all you need.''. Durchgeführt wurde dieser via Videoanruf
mit geteiltem Bildschirm.

\medskip

Die Teilnehmer arbeiteten das erste Mal mit der CLI. Um Erlernbarkeit zu
testen und trotzdem vergleichbare Performancemetriken zu erhalten wurde den
Teilnehmer eine Einführung in die CLI gegeben. In welcher alle Funktionalität
gezeigt und beschrieben wurde. Inklusive dem Auffinden von Hilfe und Shell
Basics wie \codeinline{CTRL+c} zum unterbrechen von interaktiver Eingabe
und Anführungszeichen um gruppieren von Text (\codeinline{-d "next monday"}
$\leftrightarrow$ \codeinline{-d next monday}, letzteres führt zu einem Fehler.)
Alles um zu gewährleisten das der Teilnehmer ohne das Eingreifen des Testleiters
die gegebene Aufgabe lösen kann.

\subsection{Aufgabenstellungen}
\label{aufgaben}

Es sollten die selben Aufgaben in beiden System erledigt werden. Um die beiden
Apps vergleichbar zu machen wurde die Schnittmenge der Funktionalitäten
genommen. Also nur solche die von beiden angeboten wird. Die zu testende
Funktionalität wurde also das Verwalten von Stunden und Notizen beschränkt.

\smallskip

% TODO: erlehrnbarkeit
Auf Anratens von Prof. Israel wurde deshalb eine
Menge von 20 Aufgaben gewählt.

\smallskip

Die Studie wurde auf Englisch durchgeführt. Deshalb sind die Aufgaben hier
auch im originalen Wortlaut wiedergegeben. Der Einfachheit halber wurden die
Projekt/Task Detail angaben hier weggelassen. Diese sahen in etwa so aus:
`(INTET999DXD - Germany DU Bench Time / 01 - Bench)' und bezeichneten welche
Projekt/Task Detail genau gemeint war.

\begin{enumerate}
  \item Add 8 hours for today on the Bench.
  \item Describe that you worked on "Self-Learning" during that time today.
  \item Add another 8 hours for tomorrow on the Bench.
  \item Change the 8 hours for tomorrow to 6.
  \item Remove the 6 hours for tomorrow.
  \item Log 2 hours on the Bench for Friday this week.
  \item Add 6 hours on "People Development - Certification" for Friday this week.
  \item Describe that you did a "Node.js Certificate" in the hours you just logged.
  \item Change todays 8 hours on the bench to 2.
  \item And delete your note ("Self-Learning") for today.
  \item Add 4 hours of Dev Discipline for today.
  \item Add 4 hours of Testing Discipline for today.
  \item Add 3 hours of both Testing Discipline and Dev Discipline for Monday of this week.
  \item Log 6 hours on the bench for Monday, Tuesday and Wednesday of next week.
  \item Add a note for Monday of next week that you "Played around with Golang".
  \item Change the just added note to "Played around with Rust".
  \item Change the hours for next weeks Tuesday and Wednesday to 8.
  \item Delete the hours logged for next weeks Wednesday.
  \item Show and tell Jonathan how many hours you worked in total for this week.
  \item Show and tell Jonathan how many hours you logged for the Bench next week.
\end{enumerate}

Das Hinzufügen zum System spielt die Hauptrolle. In der echten Verwendung wäre
das \codeinline{add} Kommando auch das meist verwendete.

Die Anzahl von Aufgaben welche pro Kommando erledigt werden:
\begin{itemize}
  \item 8: \codeinline{hour add}
  \item 3: \codeinline{note add}
  \item 3: \codeinline{hour edit}
  \item 2: \codeinline{hour remove}
  \item 2: \codeinline{hour list}
  \item 1: \codeinline{note edit}
  \item 1: \codeinline{note remove}
\end{itemize}

Um das Spielfeld etwas zu ebnen, wurde nicht immer der gleiche Wortlaut für
Verben wie `remove' verwendet. Sondern auch das synonyme `delete'. Die CLI
verwendet das Verb \codeinline{remove} als Subkommando. Und dies führte,
u.a. durch Verwendung von `delete', dazu das Teilnehmer versuchten etwa
\codeinline{hour delete} zu nutzen. Andere Beispiele für diese Synonyme sind
`describe' $\leftrightarrow$ `add', `change` $\leftrightarrow$ `edit' und `log'
$\leftrightarrow$ `add'. Die Sätze meinen immer noch dasselbe, fordern die
Teilnehmer bei der Verwendung der CLI aber etwas mehr heraus.

Aufgrund der unterschiedlichen Einschränkungen der beiden User Interfaces waren
manche Aufgaben mit dem einen oder anderen theoretisch einfacher zu erledigen.
In der Auswertung wird auf diese Effekte bei spezifischen Aufgaben genauer
eingegangen.

\subsection{Erhobene Daten}

Um die Performance zu messen wurde aufgezeichnet wie lange ein Benutzer
benötigt um eine gegebene Aufgabe zu erfüllen. Dazu wurden die Test Sitzungen
aufgezeichnet und dannach die Zeitmarken von Beginn und Beendung einer Aufgabe
notiert.

Einschätzung der Attraktivität beider Oberflächen erfragt. Wie auf Abbildung
\ref{fig:survey-values} zu sehen ist, bewerten die Teilnehmer die Apps auf einer
Skala zwischen zwei Adjektiven.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{survey-values.png}
  \caption{Beurteilungsbogen der kurzen AttrakDiff Studie}
  \label{fig:survey-values}
\end{figure}

\subsection{Hypothesen}

\newcounter{hypo}
\newenvironment{hypo}[1][]{
  \refstepcounter{hypo}
  Hypothese \thehypo:#1
  \label{hypo:\thehypo}
}

% TODO: Erörtern was Vorstellung, warum Hypothese relevant
Diese Hypothesen sollen durch die erhobenen Daten adressiert werden.

% TODO: style w/ label

\begin{hypo}{Die CLI hat im Durchschnitt eine ähnliche Performance wie die GUI.}\end{hypo}
\begin{hypo}{Die Performance der CLI verbessert sich im Verlaufe des Tests.}\end{hypo}
\begin{hypo}{Die CLI wird der GUI subjektiv vorgezogen.}\end{hypo}

% TODO: rework
Hypothese \ref{hypo:1} bewertet die Performance Unterschiede zwischen den beiden
Applikationen.

Hypothese \ref{hypo:2} soll Erlernbarkeit bewerten. Den Teilnehmer wurde ja
durch die Anzahl der Aufgaben genug Zeit gegeben sich mit der App vertraut zu machen.

Die \ref{hypo:3}. Hypothese bezieht sich auf das Gefühl der Teilnehmer  % TODO: finish

\subsection{Durchführung}

Nach einer generellen Einführung und Installation der App auf der Maschine des
Teilnehmers begann der Teilnehmer entweder mit der GUI Webapp oder der CLI
Applikation. 50\% der Teilnehmer begannen mit der einen, die andere Hälfte mit
der anderen. Vor der Verwendung der CLI App gab es eine Einführung, welche
dazu diente den Teilnehmer mit dem System und dessen Möglichkeiten vertraut
zu machen. Als Ausgleich dafür das die Teilnehmer alle schon mit der GUI
Variante vertraut waren. Mit dem Hinweis darauf, dass der Versuchsleiter keine
Hilfestellung leisten würde, ging es mit der Bearbeitung der Aufgaben los.
Die Checkliste der Aufgaben waren eine nach der anderen zu bewältigen. Nach
Erledigung der Aufgaben folgte die Attraktivitätsumfrage, gefolgt von der
Bearbeitung derselben Aufgaben im anderen System, sowie erneuter Umfrage.

\section{Auswertung}

Bei keinem einzigen Teilnehmer wurde weder GUI noch CLI durchgehend optimal
verwendet. Manche Heransgehensweisen waren besser als andere. Es war jedoch
zu beobachten das suboptimale Lösungswege in der GUI tendenziell beibehalten
wurden. Während bei der CLI tendenziell mit dem durchlaufen der Aufgaben bessere
Lösungswege gefunden wurden.

%%% Finish
\chapter{Zusammenfassung}
\label{sec:zusammenfassung}

% [Aggregierte retrograde Kurzbeschreibung der Arbeit]
\section{Schlussfolgerungen}
% [Beschreibung der insgesamt zu konstatierenden Schlussfolgerungen im Zusammenhang mit der Arbeit]
\section{Limitationen}
% [Beschreibung der Ergebnisse einer kritischen Reflektion und Begr\"undung dessen, was die Arbeit nicht zu leisten vermag]
\section{Ausblick}
\subsection{Entwicklung und Strukturierung von Methoden}

Die Methoden könnten in stärker strukturierter Form und außerhalb des Kontextes
dieser Arbeit für sich stehend formuliert werden. Zusammen mit einer englischen
Übersetzung wären sie dadurch dann leichter referenzier- und implementierbar.
\\
Auch könnten noch weitere Methoden entwickelt werden.

\subsection{Verbesserung der Implementation}

Die Implementierung hat noch einige Schwächen. Neben Versäumnissen etwa wie bei
der Autovervollständigung (vgl. Kap. \ref{sec:impl-autocomplete}), dem Menü
Interface (vgl. Kap. \ref{sec:impl-menu}) oder den fehlenden Synonymen (vgl.
Kap. \ref{sec:sol-natural-lang}) gibt es noch einige kleiner Fehler und Features
die anzugehen sind.

\medskip

Eine Anbindung an Oracle selbst war im Rahmen dieser Arbeit nicht vorgesehen,
weil der Fokus auf den Methoden lag. Als zukünftige Verbesserung der App wäre
dies aufgrund der Zeitersparnis aber sinnvoll.

%%% possible modules
% \section{Kontext}
% \subsection{Domain}
% \subsection{Technologien}
% \subsection{Methoden und Konzepte}
% \section{...}
% \subsection{...}
% \subsection{...}
% \chapter{Anforderungserhebung und -analyse}
% \section{Nutzer- und Systemanforderungen}
% \subsection{Funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \subsection{Nicht-funktionale Anforderungen}
% \subsubsection{Obligatorisch (MUSS)}
% \subsubsection{Fakultativ (Kann)}
% \section{...}
% \chapter{Konzeption \& Entwurf}
% [Beschreibung des Entwurfs auf Basis der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen (i.A. der Art der Arbeit)]
% \section{Prozess}
% \section{Systemarchitektur}
% \section{Softwarearchitektur}
% \section{Schnittstellen}
% \section{Datenmanagement}
% \section{...}
% \chapter{Implementierung}
% [Beschreibung der Implementierung\footnotemark auf Basis des Entwurfs und der Methodologie / der geplanten Vorgehensweise zur Probleml\"osung im Kontext der Anforderungen. Hier ist Raum f\"ur Listings, wie z.B. das nun Folgende: Umfangreicher Quell-Code sollte in den Anhang ausgelagert werden.]
% \chapter{Test}
% [Beschreibung, wie Sie auf Basis des geplanten Testvorgehens was mit welchen Kriterien und Technologien getestet haben]
% \chapter{Darstellung und Bewertung der Ergebnisse}
% [Beschreibung der Ergebnisse aus allen voran gegangenen Kapiteln sowie der zuvor generierten Ergebnisartefakte mit Bewertung, wie diese einzuordnen sind]

% \bibliographystyle{apalike}
% \bibliographystyle{ksfh_nat} % ein anderer Stil
% \bibliography{science}
\printbibliography[
heading=bibintoc,
title={Quellenverzeichnis}
]

\newpage
\chapter{Glossar}
\begin{appendix}
\pagenumbering{Roman}
\chapter{Appendix}

% \section{Quell-Code}
%
% \section{Tipps zum Schreiben Ihrer Abschlussarbeit}
%
% \begin{itemize}
% \item Achten Sie auf eine neutrale, fachliche Sprache. Keine \glqq{}Ich\grqq{}-Form.
% \item Zitieren Sie zitierf\"ahige und -w\"urdige Quellen (z.B. wissenschaftliche Artikel und Fachb\"ucher; nach M\"oglichkeit keine Blogs und keinesfalls Wikipedia.
% \item Zitieren Sie korrekt und homogen.
% \item Verwenden Sie keine Fu{\ss}noten f\"ur die Literaturangaben.
% \item Recherchieren Sie ausf\"uhrlich den Stand der Wissenschaft und Technik.
% \item Achten Sie auf die Qualit\"at der Ausarbeitung (z.B. auf Rechtschreibung).
% \item Informieren Sie sich ggf. vorab dar\"uber, wie man wissenschaftlich arbeitet bzw. schreibt:
% \begin{itemize}
% \item Mittels Fachliteratur\footnote{Z.B. \autocite{balzert2011}, \autocite{franck2013}}, oder
% \item Beim Lernzentrum\footnote{Weitere Informationen zum Schreibcoaching finden sich hier: \url{https://www.htw-berlin.de/studium/lernzentrum/studierende/schreibcoaching/}; letzter Zugriff: 13 VI 19.}.
% \end{itemize}
% \end{itemize}
%
\newpage
\thispagestyle{empty}
\noindent

\section*{Eidesstattliche Versicherung}
Hiermit versichere ich an Eides statt durch meine Unterschrift, dass ich die vorstehende Arbeit selbstst\"andig und ohne fremde Hilfe angefertigt und alle Stellen, die ich w\"ortlich oder ann\"ahernd w\"ortlich aus Ver\"offentlichungen entnommen habe, als solche kenntlich gemacht habe, mich auch keiner anderen als der angegebenen Literatur oder sonstiger Hilfsmittel bedient habe. Die Arbeit hat in dieser oder \"ahnlicher Form noch keiner anderen Pr\"ufungsbeh\"orde vorgelegen.\\
\linebreak[4]
\linebreak[4]
\linebreak[4]
\linebreak[4]
-------------------------------------------------------\linebreak[4]
Datum, Ort, Unterschrift

\end{appendix}
\end{document}
